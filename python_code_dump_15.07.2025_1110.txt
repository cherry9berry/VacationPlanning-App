=========================================
PYTHON CODE DUMP
Generated: 15.07.2025 11:10:19,31
Directory: D:\Users\chernousov-am\vp on pt
=========================================


###############################################
### PROJECT STRUCTURE
###############################################

=== PROJECT STRUCTURE ===
.gitignore
backLog_aka_toDo.md
build
builder.bat
config.json
config.py
core
create_report.py
create_report.spec
dist
dumper.bat
gui
logs
main.py
models.py
python_code_dump_15.07.2025_1110.txt
readme.md
templates
tests
__pycache__
.git\COMMIT_EDITMSG
.git\config
.git\description
.git\FETCH_HEAD
.git\HEAD
.git\hooks
.git\index
.git\info
.git\logs
.git\objects
.git\refs
.git\hooks\applypatch-msg.sample
.git\hooks\commit-msg.sample
.git\hooks\fsmonitor-watchman.sample
.git\hooks\post-update.sample
.git\hooks\pre-applypatch.sample
.git\hooks\pre-commit.sample
.git\hooks\pre-merge-commit.sample
.git\hooks\pre-push.sample
.git\hooks\pre-rebase.sample
.git\hooks\pre-receive.sample
.git\hooks\prepare-commit-msg.sample
.git\hooks\update.sample
.git\info\exclude
.git\logs\HEAD
.git\logs\refs
.git\logs\refs\heads
.git\logs\refs\remotes
.git\logs\refs\heads\main
.git\logs\refs\remotes\origin
.git\logs\refs\remotes\origin\main
.git\objects\02
.git\objects\03
.git\objects\05
.git\objects\0d
.git\objects\24
.git\objects\27
.git\objects\2a
.git\objects\30
.git\objects\31
.git\objects\3b
.git\objects\3d
.git\objects\3e
.git\objects\3f
.git\objects\40
.git\objects\41
.git\objects\44
.git\objects\46
.git\objects\4a
.git\objects\4e
.git\objects\50
.git\objects\5b
.git\objects\5d
.git\objects\64
.git\objects\6b
.git\objects\6f
.git\objects\75
.git\objects\76
.git\objects\7a
.git\objects\7c
.git\objects\7f
.git\objects\86
.git\objects\88
.git\objects\8d
.git\objects\8f
.git\objects\92
.git\objects\94
.git\objects\96
.git\objects\99
.git\objects\9a
.git\objects\a1
.git\objects\a2
.git\objects\a6
.git\objects\ac
.git\objects\af
.git\objects\b3
.git\objects\b6
.git\objects\b9
.git\objects\ba
.git\objects\c0
.git\objects\c3
.git\objects\c8
.git\objects\d1
.git\objects\d6
.git\objects\d8
.git\objects\dc
.git\objects\e6
.git\objects\e9
.git\objects\f1
.git\objects\f3
.git\objects\f4
.git\objects\f8
.git\objects\fd
.git\objects\fe
.git\objects\info
.git\objects\pack
.git\objects\02\71b069a82d7ce083ab375dbe7f8b6e7b2e22ef
.git\objects\02\f5b07a62fe221a217da4a4a17746bdc2753592
.git\objects\03\d099610570f6f3fbea036877cd12ee600d3046
.git\objects\05\a6e4f2a033c5455cadf42ebc920c5374c3d99c
.git\objects\0d\4a5b836a5baf106540bf8b9dd9ad97a9c63f04
.git\objects\24\6f10ab65818c8753d978f6bb68f5443b649929
.git\objects\27\4e94d727ab1ec1f9e865fc41d714a80edd9456
.git\objects\2a\62aa8885d025d34e86a4d6aa3da77b872715f9
.git\objects\2a\7a96325032f2c4e37e2cfd0aa3b3114f4e78ab
.git\objects\30\921d65ba204fc46ea0792d97de8b07c01e3ffb
.git\objects\30\dfd0abaff31b036a3406371ebcc0769f8f2ea0
.git\objects\31\d0ddc5c22fd486c79727ca4a6fbfd969a226c5
.git\objects\31\dec8be5f8773ad2a88ba482352999e62355ee7
.git\objects\3b\84aea65411f40f35e564e2cf950fd471eb2977
.git\objects\3d\c42620dbe3d779c36e570a569d99455dd72097
.git\objects\3e\d5e5d6bc5b36aa2f631894e3aefe21f6071c2a
.git\objects\3f\965cceccc01265abec377a595920e15c314972
.git\objects\3f\e997be37ccfacd0f0ce110cc6b84e4ba7aa2bf
.git\objects\40\5bf312528e03399f31d6ce687dcc4dff3c4709
.git\objects\41\3082133f9708c8d00f991b9fc4914e7faffdb1
.git\objects\41\3ea8d2a9d8e372401e723698a438b566eab575
.git\objects\44\6d3bed5aa9b65fc320fb880e8310c52913f417
.git\objects\46\0c40ba87fb3c588d2031cf8c8398bf2bcca041
.git\objects\4a\9734c918823137ce91bbeeb93e75c4c010c520
.git\objects\4e\7b1283d8ed6056fb58091ab7eeae773cc9b08c
.git\objects\50\fee0f750519673bc052eeb22f1105e93ea77fc
.git\objects\5b\20f94425c1a37c8c77b44e87b48af65d961581
.git\objects\5d\01633f38ec53c5fcbbb2790711e1df686fa5f5
.git\objects\5d\cd3b728ab1db6239b0888b01ce57b6dde6a66a
.git\objects\64\d9203a484625ebdb4130a8675f97128436af13
.git\objects\6b\8c4b1f07253c5f83de0a28fbe8ed8ca7e07ba9
.git\objects\6f\bac8024d545a9deea5b09323767061249762ed
.git\objects\75\341e3fefaf65966a18120b0233cbe3ed532f4e
.git\objects\76\04d6fa1de9d3c3cabce2e8d935644fc7a045e9
.git\objects\76\6b335904d7ba64216b63d48b76c904e493b9a8
.git\objects\7a\0e6bea8d95fb85df72cbb1f1d3941d76e18c98
.git\objects\7c\4e32ce017fd64f64fdcc88193db2da4d1fa037
.git\objects\7f\83dfc9458f54678376aef2bdfd1d3677e615ed
.git\objects\86\84601c1cb6fefdc2c2a26030a337e2d636df07
.git\objects\88\abb85a8019874c8be706d917aaaed97cb0dfdc
.git\objects\8d\0be6f1104c0ee1c97310a420dc43574e7603ae
.git\objects\8d\0ec1341057a87ebdc38b24c86ea752d783a4de
.git\objects\8f\f2fc2edc52d1a8316174c180628da4a3428c28
.git\objects\92\0579b6df0cb5734b5f00f28d7933a6e569ce5e
.git\objects\94\6162ca3b96b6b2954f334b758f37323adda70e
.git\objects\96\21cb4fba9fcbb2ba177862cd75c6cfa68c6d42
.git\objects\99\15a93287641f113d71c52d123d522c7a5699bb
.git\objects\99\8a9477b841e98d8008d2d72f3a379ddd839c9b
.git\objects\99\d4cc5927aa06766d7fb249bf2991b009e4817c
.git\objects\9a\2dbc1d79c587bc7fbf774cd28d45d127fcd1d2
.git\objects\a1\53ebbe4889993246757e404ecc750e3b1715fc
.git\objects\a2\5f98c49b54a67b29133896d8dd486905a3aa9f
.git\objects\a2\a51692e1e07c0fb18920a3638b7b4a3285262c
.git\objects\a2\ed04c0e92ddf6c5794fc9c94e0eedd26561118
.git\objects\a6\e4b52ca8a0a02b2b1c12ac2e073c2034d73ce4
.git\objects\ac\4b68689f8fb0a19dbfb576eedb603835425d44
.git\objects\af\2c3d197540eb0660b8892296afc3af9049957a
.git\objects\af\2fa2f22185cace7c1293c2a00387bbf9c40467
.git\objects\b3\ad04e1a7b8b82b2661a73b85b1e2083cf68bba
.git\objects\b6\7a9534f6db94f309ae843825e4d9d81fbf8232
.git\objects\b9\8ed43e44aa649efe917d59f7145820f22b255f
.git\objects\ba\2d5a35023f8e9f0c1ec1471a8e9b1a921f52fb
.git\objects\c0\25de1dcf2bc65e5e5691e6c2186f4e6897958c
.git\objects\c3\f8ffa5bf5285e8791075ed8e21ab058535510d
.git\objects\c8\77b3b9e12259b33d4dd303ba49e1351c069bcb
.git\objects\d1\bc75fb1706322a3351675e584bf633fa20e838
.git\objects\d6\58f3a7af902c6d94a4e95dee5a3e493ddfbb87
.git\objects\d8\6838a4b3dea801d9de1fcc968efb7d8ff740d1
.git\objects\d8\e05718a6af31d0ac0c7d9a79dada5c88c0e4b6
.git\objects\dc\5db068387e4b2a6f2e438ae86a22f845781ad4
.git\objects\e6\ff70474a8aafe72fe1d5bbd696aac1f8566df3
.git\objects\e9\940edcaaf2268a9c888287a21f134bd5ec0c7b
.git\objects\f1\76c99e29e53f94b4456f6f739371c87ccd59e1
.git\objects\f3\1b0c399ff25a08c7ce0e7923922ac3049c5e72
.git\objects\f4\e7cad19b28e222f92aee1fe3e7f3a5778d06e1
.git\objects\f8\e6d5fcd29bd9609b4316d5cafcf724fc849479
.git\objects\fd\946fd078b1f6f0bbc85b3421e1edb3e86616bd
.git\objects\fe\22d4b84f30ef6c2096f2426f6486bb61a18d5b
.git\refs\heads
.git\refs\remotes
.git\refs\tags
.git\refs\heads\main
.git\refs\remotes\origin
.git\refs\remotes\origin\main
build\create_report
build\VacationTool
build\create_report\Analysis-00.toc
build\create_report\base_library.zip
build\create_report\create_report.pkg
build\create_report\EXE-00.toc
build\create_report\localpycs
build\create_report\PKG-00.toc
build\create_report\PYZ-00.pyz
build\create_report\PYZ-00.toc
build\create_report\warn-create_report.txt
build\create_report\xref-create_report.html
build\create_report\localpycs\pyimod01_archive.pyc
build\create_report\localpycs\pyimod02_importers.pyc
build\create_report\localpycs\pyimod03_ctypes.pyc
build\create_report\localpycs\pyimod04_pywin32.pyc
build\create_report\localpycs\struct.pyc
build\VacationTool\Analysis-00.toc
build\VacationTool\base_library.zip
build\VacationTool\EXE-00.toc
build\VacationTool\localpycs
build\VacationTool\PKG-00.toc
build\VacationTool\PYZ-00.pyz
build\VacationTool\PYZ-00.toc
build\VacationTool\VacationTool.pkg
build\VacationTool\warn-VacationTool.txt
build\VacationTool\xref-VacationTool.html
build\VacationTool\localpycs\pyimod01_archive.pyc
build\VacationTool\localpycs\pyimod02_importers.pyc
build\VacationTool\localpycs\pyimod03_ctypes.pyc
build\VacationTool\localpycs\pyimod04_pywin32.pyc
build\VacationTool\localpycs\struct.pyc
core\excel_handler.py
core\file_manager.py
core\processor.py
core\validator.py
core\__pycache__
core\__pycache__\excel_handler.cpython-311.pyc
core\__pycache__\file_manager.cpython-311.pyc
core\__pycache__\processor.cpython-311.pyc
core\__pycache__\validator.cpython-311.pyc
dist\config.json
dist\create_report.exe
dist\logs
dist\VacationTool.exe
dist\logs\vacation_tool.log
gui\create_files_window.py
gui\main_window.py
gui\reports_window.py
gui\__pycache__
gui\__pycache__\create_files_window.cpython-311.pyc
gui\__pycache__\main_window.cpython-311.pyc
gui\__pycache__\reports_window.cpython-311.pyc
logs\vacation_tool.log
templates\block_report_template v2.xlsx
templates\block_report_template v3.xlsx
templates\block_report_template — копия.xlsx
templates\block_report_template.xlsx
templates\employee_template v1.1.xlsx
templates\employee_template v2 макет.xlsx
templates\employee_template v3 макет.xlsx
templates\employee_template.xlsx
templates\global_report_template пример .xlsx
templates\global_report_template.xlsx
tests\backlog
tests\test3
tests\test4
tests\Файл с сотрудниками с пятой строки.xlsx
tests\test3\Административно-управленческий персонал
tests\test3\Блок банковских технологий
tests\test3\Блок больших данных
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений
tests\test3\Блок ИТ-развития инвестиционного бизнеса
tests\test3\Блок ИТ-развития корпоративного бизнеса
tests\test3\Блок ИТ-развития фронтальных решений розничного бизнеса
tests\test3\Блок кредитного корпоративного бизнеса
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО
tests\test3\Блок проектного офиса
tests\test3\Блок развития внутрибанковских систем
tests\test3\Блок развития и поддержки АБС
tests\test3\Блок цифровой трансформации
tests\test3\ОБЩИЙ_ОТЧЕТ_20250708_171722.xlsx
tests\test3\ОБЩИЙ_ОТЧЕТ_20250708_171851.xlsx
tests\test3\ОБЩИЙ_ОТЧЕТ_20250710_153809.xlsx
tests\test3\ОБЩИЙ_ОТЧЕТ_20250710_154639.xlsx
tests\test3\Административно-управленческий персонал\Митюшкина Виктория Вячеславовна (00164543).xlsx
tests\test3\Административно-управленческий персонал\Отчет по блоку_Административно-управленческий персонал_20250708_165851.xlsx
tests\test3\Административно-управленческий персонал\Отчет по блоку_Административно-управленческий персонал_20250708_171309.xlsx
tests\test3\Административно-управленческий персонал\Отчет по блоку_Административно-управленческий персонал_20250710_153639.xlsx
tests\test3\Административно-управленческий персонал\Отчет по блоку_Административно-управленческий персонал_20250710_154510.xlsx
tests\test3\Блок банковских технологий\create_report.py
tests\test3\Блок банковских технологий\Абрамова Светлана Сергеевна (00091831).xlsx
tests\test3\Блок банковских технологий\Баженов Иван Федорович (00136394).xlsx
tests\test3\Блок банковских технологий\Баркалова Регина Андреевна (00099872).xlsx
tests\test3\Блок банковских технологий\Белоусова Ольга Юрьевна (00216506).xlsx
tests\test3\Блок банковских технологий\Блинова Александра Александровна (00102539).xlsx
tests\test3\Блок банковских технологий\Быкова Татьяна Васильевна (00215939).xlsx
tests\test3\Блок банковских технологий\Вельдина Наталья Алексеевна (00097357).xlsx
tests\test3\Блок банковских технологий\Вышегородская Светлана Валерьевна (00101277).xlsx
tests\test3\Блок банковских технологий\Гайворонский Сергей Васильевич (00125871).xlsx
tests\test3\Блок банковских технологий\Гайфулина Ирина Юрьевна (00107391).xlsx
tests\test3\Блок банковских технологий\Журихина Зоя Владимировна (00176344).xlsx
tests\test3\Блок банковских технологий\Кусачева Валерия Владимировна (00108750).xlsx
tests\test3\Блок банковских технологий\Миронова Марина Львовна (00157484).xlsx
tests\test3\Блок банковских технологий\Мотылев Максим Артурович (00208779).xlsx
tests\test3\Блок банковских технологий\Отчет по блоку_Блок банковских технологий_20250708_170309.xlsx
tests\test3\Блок банковских технологий\Отчет по блоку_Блок банковских технологий_20250708_173618.xlsx
tests\test3\Блок банковских технологий\Отчет по блоку_Блок банковских технологий_20250710_153643.xlsx
tests\test3\Блок банковских технологий\Отчет по блоку_Блок банковских технологий_20250710_154514.xlsx
tests\test3\Блок банковских технологий\Репина Олеся Владимировна (00091432).xlsx
tests\test3\Блок банковских технологий\Соловьева Анастасия Сергеевна (00120342).xlsx
tests\test3\Блок банковских технологий\Часовских Екатерина Александровна (00216105).xlsx
tests\test3\Блок больших данных\Дмитриев Данила Вадимович (00186577).xlsx
tests\test3\Блок больших данных\Муртазин Марат Салаватович (00203692).xlsx
tests\test3\Блок больших данных\Отчет по блоку_Блок больших данных_20250708_165853.xlsx
tests\test3\Блок больших данных\Отчет по блоку_Блок больших данных_20250708_171312.xlsx
tests\test3\Блок больших данных\Отчет по блоку_Блок больших данных_20250710_153646.xlsx
tests\test3\Блок больших данных\Отчет по блоку_Блок больших данных_20250710_154517.xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Аникина Светлана Александровна (00169574).xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Лозанов Кирилл Викторович (00203023).xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Новиков Глеб Евгеньевич (00212478).xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Отчет по блоку_Блок внутренней разработки, платформенных и интеграционных решений_20250708_165856.xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Отчет по блоку_Блок внутренней разработки, платформенных и интеграционных решений_20250708_171315.xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Отчет по блоку_Блок внутренней разработки, платформенных и интеграционных решений_20250710_153649.xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Отчет по блоку_Блок внутренней разработки, платформенных и интеграционных решений_20250710_154520.xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Рябцов Алексей Владимирович (00217745).xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Сергеев Андрей Анатольевич (00138090).xlsx
tests\test3\Блок внутренней разработки, платформенных и интеграционных решений\Школьников Герман Эдуардович (00103397).xlsx
tests\test3\Блок ИТ-развития инвестиционного бизнеса\Жихарев Сергей Александрович (00172428).xlsx
tests\test3\Блок ИТ-развития инвестиционного бизнеса\Мороз Евгений Игоревич (00183681).xlsx
tests\test3\Блок ИТ-развития инвестиционного бизнеса\Отчет по блоку_Блок ИТ-развития инвестиционного бизнеса_20250708_171318.xlsx
tests\test3\Блок ИТ-развития инвестиционного бизнеса\Отчет по блоку_Блок ИТ-развития инвестиционного бизнеса_20250710_153651.xlsx
tests\test3\Блок ИТ-развития инвестиционного бизнеса\Отчет по блоку_Блок ИТ-развития инвестиционного бизнеса_20250710_154522.xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Агаризаева Зарема Агаризаевна (00157887).xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Богданов Павел Николаевич (00146921).xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Гонсалес Юрий Альфредович (00147155).xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Отчет по блоку_Блок ИТ-развития корпоративного бизнеса_20250708_165902.xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Отчет по блоку_Блок ИТ-развития корпоративного бизнеса_20250708_171321.xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Отчет по блоку_Блок ИТ-развития корпоративного бизнеса_20250710_153654.xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Отчет по блоку_Блок ИТ-развития корпоративного бизнеса_20250710_154525.xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Поляков Дмитрий Игоревич (00180083).xlsx
tests\test3\Блок ИТ-развития корпоративного бизнеса\Сотников Владимир Александрович (00146513).xlsx
tests\test3\Блок ИТ-развития фронтальных решений розничного бизнеса\Билалов Алмаз Равдатович (00094718).xlsx
tests\test3\Блок ИТ-развития фронтальных решений розничного бизнеса\Зарубина Светлана Николаевна (00147055).xlsx
tests\test3\Блок ИТ-развития фронтальных решений розничного бизнеса\Кожевников Константин Сергеевич (00158310).xlsx
tests\test3\Блок ИТ-развития фронтальных решений розничного бизнеса\Отчет по блоку_Блок ИТ-развития фронтальных решений розничного бизнеса_20250708_165905.xlsx
tests\test3\Блок ИТ-развития фронтальных решений розничного бизнеса\Отчет по блоку_Блок ИТ-развития фронтальных решений розничного бизнеса_20250708_171324.xlsx
tests\test3\Блок ИТ-развития фронтальных решений розничного бизнеса\Отчет по блоку_Блок ИТ-развития фронтальных решений розничного бизнеса_20250710_153657.xlsx
tests\test3\Блок ИТ-развития фронтальных решений розничного бизнеса\Отчет по блоку_Блок ИТ-развития фронтальных решений розничного бизнеса_20250710_154528.xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Андрюшкевич Илья Константинович (00169173).xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Борзенко Максим Александрович (00132807).xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Зубков Владлен Владимирович (00208923).xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Матвеев Иван Евгеньевич (00132799).xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Морунов Александр Сергеевич (00194703).xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Отчет по блоку_Блок кредитного корпоративного бизнеса_20250708_165908.xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Отчет по блоку_Блок кредитного корпоративного бизнеса_20250708_171327.xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Отчет по блоку_Блок кредитного корпоративного бизнеса_20250710_153659.xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Отчет по блоку_Блок кредитного корпоративного бизнеса_20250710_154531.xlsx
tests\test3\Блок кредитного корпоративного бизнеса\Якимец Елизавета Сергеевна (00157666).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\create_report.py
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Власов Евгений Николаевич (00111025).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Галиакберова Марина Валериановна (00128067).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Гудков Егор Кириллович (00203305).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Ермишов Олег Николаевич (00189622).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Зайнагова Алина Радимовна (00126118).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Лысенко Алексей Евгеньевич (00186358).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Отчет по блоку_Блок обеспечения и контроля качества выпуска изменений ПО_20250708_165911.xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Отчет по блоку_Блок обеспечения и контроля качества выпуска изменений ПО_20250708_171331.xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Отчет по блоку_Блок обеспечения и контроля качества выпуска изменений ПО_20250710_153703.xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Отчет по блоку_Блок обеспечения и контроля качества выпуска изменений ПО_20250710_154534.xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Отчет по блоку_Блок обеспечения и контроля качества выпуска изменений ПО_20250711_093036.xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Семерикова Светлана Николаевна (00150819).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Станкевич Татьяна Владимировна (00140726).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Шайбакова Аделия Рустемовна (00202225).xlsx
tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\Якупова Айгуль Ильдаровна (00185292).xlsx
tests\test3\Блок проектного офиса\Анисимова Аниса Рамисовна (00113100).xlsx
tests\test3\Блок проектного офиса\Данзурун Максим Сергеевич (00150195).xlsx
tests\test3\Блок проектного офиса\Отчет по блоку_Блок проектного офиса_20250708_165914.xlsx
tests\test3\Блок проектного офиса\Отчет по блоку_Блок проектного офиса_20250708_171334.xlsx
tests\test3\Блок проектного офиса\Отчет по блоку_Блок проектного офиса_20250710_153706.xlsx
tests\test3\Блок проектного офиса\Отчет по блоку_Блок проектного офиса_20250710_154537.xlsx
tests\test3\Блок проектного офиса\Парфутин Александр Михайлович (00189929).xlsx
tests\test3\Блок проектного офиса\Смирнова Татьяна Михайловна (00199590).xlsx
tests\test3\Блок проектного офиса\Туровская Анна Александровна (00146545).xlsx
tests\test3\Блок развития внутрибанковских систем\Зиновьев Сергей Владимирович (00190720).xlsx
tests\test3\Блок развития внутрибанковских систем\Отчет по блоку_Блок развития внутрибанковских систем_20250708_165917.xlsx
tests\test3\Блок развития внутрибанковских систем\Отчет по блоку_Блок развития внутрибанковских систем_20250708_171336.xlsx
tests\test3\Блок развития внутрибанковских систем\Отчет по блоку_Блок развития внутрибанковских систем_20250710_153708.xlsx
tests\test3\Блок развития внутрибанковских систем\Отчет по блоку_Блок развития внутрибанковских систем_20250710_154540.xlsx
tests\test3\Блок развития и поддержки АБС\Алексенко Юрий Ярославович (00089627).xlsx
tests\test3\Блок развития и поддержки АБС\Алешина Елена Петровна (00125109).xlsx
tests\test3\Блок развития и поддержки АБС\Аллилуева Светлана Александровна (00130481).xlsx
tests\test3\Блок развития и поддержки АБС\Анисимов Алексей Алексеевич (00113053).xlsx
tests\test3\Блок развития и поддержки АБС\Габитов Рустам Наилович (00091758).xlsx
tests\test3\Блок развития и поддержки АБС\Гилязев Ильгиз Рафисович (00107100).xlsx
tests\test3\Блок развития и поддержки АБС\Глебова Юлия Александровна (00103076).xlsx
tests\test3\Блок развития и поддержки АБС\Горонкова Айгуль Рамилевна (00091744).xlsx
tests\test3\Блок развития и поддержки АБС\Гофферт Валентина Владимировна (00094735).xlsx
tests\test3\Блок развития и поддержки АБС\Грунтовский Денис Александрович (00125112).xlsx
tests\test3\Блок развития и поддержки АБС\Журавлёва Любовь Александровна (00132518).xlsx
tests\test3\Блок развития и поддержки АБС\Каримова Альбина Ринатовна (00138841).xlsx
tests\test3\Блок развития и поддержки АБС\Кот Екатерина Юрьевна (00137688).xlsx
tests\test3\Блок развития и поддержки АБС\Кочихина Яна Сергеевна (00197511).xlsx
tests\test3\Блок развития и поддержки АБС\Кочубей Неля Александровна (00091370).xlsx
tests\test3\Блок развития и поддержки АБС\Кречетов Павел Валерьевич (00169558).xlsx
tests\test3\Блок развития и поддержки АБС\Кудрина Кристина Владимировна (00214497).xlsx
tests\test3\Блок развития и поддержки АБС\Лужецкая Бэла Леонидовна (00155603).xlsx
tests\test3\Блок развития и поддержки АБС\Мокин Роман Александрович (00135622).xlsx
tests\test3\Блок развития и поддержки АБС\Муранова Ирина Олеговна (00140293).xlsx
tests\test3\Блок развития и поддержки АБС\Отчет по блоку_Блок развития и поддержки АБС_20250708_165922.xlsx
tests\test3\Блок развития и поддержки АБС\Отчет по блоку_Блок развития и поддержки АБС_20250708_171342.xlsx
tests\test3\Блок развития и поддержки АБС\Отчет по блоку_Блок развития и поддержки АБС_20250710_153714.xlsx
tests\test3\Блок развития и поддержки АБС\Отчет по блоку_Блок развития и поддержки АБС_20250710_154545.xlsx
tests\test3\Блок развития и поддержки АБС\Рафиков Алмаз Минихамитович (00107667).xlsx
tests\test3\Блок развития и поддержки АБС\Старцев Евгений Сергеевич (00116286).xlsx
tests\test3\Блок развития и поддержки АБС\Трубаков Александр Владимирович (00155775).xlsx
tests\test3\Блок цифровой трансформации\Бароян Анжела Гайковна (00116117).xlsx
tests\test3\Блок цифровой трансформации\Вакулина Ольга Сергеевна (00218208).xlsx
tests\test3\Блок цифровой трансформации\Валеев Станислав Салаватович (00150639).xlsx
tests\test3\Блок цифровой трансформации\Зуев Павел Сергеевич (00197754).xlsx
tests\test3\Блок цифровой трансформации\Отчет по блоку_Блок цифровой трансформации_20250708_165925.xlsx
tests\test3\Блок цифровой трансформации\Отчет по блоку_Блок цифровой трансформации_20250708_171346.xlsx
tests\test3\Блок цифровой трансформации\Отчет по блоку_Блок цифровой трансформации_20250710_153717.xlsx
tests\test3\Блок цифровой трансформации\Отчет по блоку_Блок цифровой трансформации_20250710_154548.xlsx
tests\test3\Блок цифровой трансформации\Стрелкова Дарья Сергеевна (00216772).xlsx
tests\test3\Блок цифровой трансформации\Фоминых Артём Владимирович (00218402).xlsx
tests\test3\Блок цифровой трансформации\Эшмирзаев Жасур Сайфиддинович (00137074).xlsx
tests\test4\Административно-управленческий персонал
tests\test4\Блок банковских технологий
tests\test4\Блок больших данных
tests\test4\Блок внутренней разработки, платформенных и интеграционных решений
tests\test4\Блок ИТ-развития инвестиционного бизнеса
tests\test4\Блок ИТ-развития корпоративного бизнеса
tests\test4\Блок ИТ-развития фронтальных решений розничного бизнеса
tests\test4\Блок кредитного корпоративного бизнеса
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО
tests\test4\Блок проектного офиса
tests\test4\Блок развития внутрибанковских систем
tests\test4\Блок развития и поддержки АБС
tests\test4\Блок цифровой трансформации
tests\test4\ОБЩИЙ_ОТЧЕТ_20250715_102352.xlsx
tests\test4\Административно-управленческий персонал\Митюшкина Виктория Вячеславовна (00164543).xlsx
tests\test4\Административно-управленческий персонал\Отчет по блоку_Административно-управленческий персонал_20250715_102203.xlsx
tests\test4\Блок банковских технологий\Абрамова Светлана Сергеевна (00091831).xlsx
tests\test4\Блок банковских технологий\Баженов Иван Федорович (00136394).xlsx
tests\test4\Блок банковских технологий\Баркалова Регина Андреевна (00099872).xlsx
tests\test4\Блок банковских технологий\Белоусова Ольга Юрьевна (00216506).xlsx
tests\test4\Блок банковских технологий\Блинова Александра Александровна (00102539).xlsx
tests\test4\Блок банковских технологий\Быкова Татьяна Васильевна (00215939).xlsx
tests\test4\Блок банковских технологий\Вельдина Наталья Алексеевна (00097357).xlsx
tests\test4\Блок банковских технологий\Вышегородская Светлана Валерьевна (00101277).xlsx
tests\test4\Блок банковских технологий\Гайворонский Сергей Васильевич (00125871).xlsx
tests\test4\Блок банковских технологий\Гайфулина Ирина Юрьевна (00107391).xlsx
tests\test4\Блок банковских технологий\Журихина Зоя Владимировна (00176344).xlsx
tests\test4\Блок банковских технологий\Кусачева Валерия Владимировна (00108750).xlsx
tests\test4\Блок банковских технологий\Миронова Марина Львовна (00157484).xlsx
tests\test4\Блок банковских технологий\Мотылев Максим Артурович (00208779).xlsx
tests\test4\Блок банковских технологий\Отчет по блоку_Блок банковских технологий_20250715_102207.xlsx
tests\test4\Блок банковских технологий\Репина Олеся Владимировна (00091432).xlsx
tests\test4\Блок банковских технологий\Соловьева Анастасия Сергеевна (00120342).xlsx
tests\test4\Блок банковских технологий\Часовских Екатерина Александровна (00216105).xlsx
tests\test4\Блок больших данных\Дмитриев Данила Вадимович (00186577).xlsx
tests\test4\Блок больших данных\Муртазин Марат Салаватович (00203692).xlsx
tests\test4\Блок больших данных\Отчет по блоку_Блок больших данных_20250715_102210.xlsx
tests\test4\Блок внутренней разработки, платформенных и интеграционных решений\Аникина Светлана Александровна (00169574).xlsx
tests\test4\Блок внутренней разработки, платформенных и интеграционных решений\Лозанов Кирилл Викторович (00203023).xlsx
tests\test4\Блок внутренней разработки, платформенных и интеграционных решений\Новиков Глеб Евгеньевич (00212478).xlsx
tests\test4\Блок внутренней разработки, платформенных и интеграционных решений\Отчет по блоку_Блок внутренней разработки, платформенных и интеграционных решений_20250715_102212.xlsx
tests\test4\Блок внутренней разработки, платформенных и интеграционных решений\Рябцов Алексей Владимирович (00217745).xlsx
tests\test4\Блок внутренней разработки, платформенных и интеграционных решений\Сергеев Андрей Анатольевич (00138090).xlsx
tests\test4\Блок внутренней разработки, платформенных и интеграционных решений\Школьников Герман Эдуардович (00103397).xlsx
tests\test4\Блок ИТ-развития инвестиционного бизнеса\Жихарев Сергей Александрович (00172428).xlsx
tests\test4\Блок ИТ-развития инвестиционного бизнеса\Мороз Евгений Игоревич (00183681).xlsx
tests\test4\Блок ИТ-развития инвестиционного бизнеса\Отчет по блоку_Блок ИТ-развития инвестиционного бизнеса_20250715_102215.xlsx
tests\test4\Блок ИТ-развития корпоративного бизнеса\Агаризаева Зарема Агаризаевна (00157887).xlsx
tests\test4\Блок ИТ-развития корпоративного бизнеса\Богданов Павел Николаевич (00146921).xlsx
tests\test4\Блок ИТ-развития корпоративного бизнеса\Гонсалес Юрий Альфредович (00147155).xlsx
tests\test4\Блок ИТ-развития корпоративного бизнеса\Отчет по блоку_Блок ИТ-развития корпоративного бизнеса_20250715_102218.xlsx
tests\test4\Блок ИТ-развития корпоративного бизнеса\Поляков Дмитрий Игоревич (00180083).xlsx
tests\test4\Блок ИТ-развития корпоративного бизнеса\Сотников Владимир Александрович (00146513).xlsx
tests\test4\Блок ИТ-развития фронтальных решений розничного бизнеса\Билалов Алмаз Равдатович (00094718).xlsx
tests\test4\Блок ИТ-развития фронтальных решений розничного бизнеса\Зарубина Светлана Николаевна (00147055).xlsx
tests\test4\Блок ИТ-развития фронтальных решений розничного бизнеса\Кожевников Константин Сергеевич (00158310).xlsx
tests\test4\Блок ИТ-развития фронтальных решений розничного бизнеса\Отчет по блоку_Блок ИТ-развития фронтальных решений розничного бизнеса_20250715_102220.xlsx
tests\test4\Блок кредитного корпоративного бизнеса\Андрюшкевич Илья Константинович (00169173).xlsx
tests\test4\Блок кредитного корпоративного бизнеса\Борзенко Максим Александрович (00132807).xlsx
tests\test4\Блок кредитного корпоративного бизнеса\Зубков Владлен Владимирович (00208923).xlsx
tests\test4\Блок кредитного корпоративного бизнеса\Матвеев Иван Евгеньевич (00132799).xlsx
tests\test4\Блок кредитного корпоративного бизнеса\Морунов Александр Сергеевич (00194703).xlsx
tests\test4\Блок кредитного корпоративного бизнеса\Отчет по блоку_Блок кредитного корпоративного бизнеса_20250715_102224.xlsx
tests\test4\Блок кредитного корпоративного бизнеса\Якимец Елизавета Сергеевна (00157666).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Власов Евгений Николаевич (00111025).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Галиакберова Марина Валериановна (00128067).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Гудков Егор Кириллович (00203305).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Ермишов Олег Николаевич (00189622).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Зайнагова Алина Радимовна (00126118).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Лысенко Алексей Евгеньевич (00186358).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Отчет по блоку_Блок обеспечения и контроля качества выпуска изменений ПО_20250715_102227.xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Семерикова Светлана Николаевна (00150819).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Станкевич Татьяна Владимировна (00140726).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Шайбакова Аделия Рустемовна (00202225).xlsx
tests\test4\Блок обеспечения и контроля качества выпуска изменений ПО\Якупова Айгуль Ильдаровна (00185292).xlsx
tests\test4\Блок проектного офиса\Анисимова Аниса Рамисовна (00113100).xlsx
tests\test4\Блок проектного офиса\Данзурун Максим Сергеевич (00150195).xlsx
tests\test4\Блок проектного офиса\Отчет по блоку_Блок проектного офиса_20250715_102230.xlsx
tests\test4\Блок проектного офиса\Парфутин Александр Михайлович (00189929).xlsx
tests\test4\Блок проектного офиса\Смирнова Татьяна Михайловна (00199590).xlsx
tests\test4\Блок проектного офиса\Туровская Анна Александровна (00146545).xlsx
tests\test4\Блок развития внутрибанковских систем\Зиновьев Сергей Владимирович (00190720).xlsx
tests\test4\Блок развития внутрибанковских систем\Отчет по блоку_Блок развития внутрибанковских систем_20250715_102233.xlsx
tests\test4\Блок развития и поддержки АБС\Алексенко Юрий Ярославович (00089627).xlsx
tests\test4\Блок развития и поддержки АБС\Алешина Елена Петровна (00125109).xlsx
tests\test4\Блок развития и поддержки АБС\Аллилуева Светлана Александровна (00130481).xlsx
tests\test4\Блок развития и поддержки АБС\Анисимов Алексей Алексеевич (00113053).xlsx
tests\test4\Блок развития и поддержки АБС\Габитов Рустам Наилович (00091758).xlsx
tests\test4\Блок развития и поддержки АБС\Гилязев Ильгиз Рафисович (00107100).xlsx
tests\test4\Блок развития и поддержки АБС\Глебова Юлия Александровна (00103076).xlsx
tests\test4\Блок развития и поддержки АБС\Горонкова Айгуль Рамилевна (00091744).xlsx
tests\test4\Блок развития и поддержки АБС\Гофферт Валентина Владимировна (00094735).xlsx
tests\test4\Блок развития и поддержки АБС\Грунтовский Денис Александрович (00125112).xlsx
tests\test4\Блок развития и поддержки АБС\Журавлёва Любовь Александровна (00132518).xlsx
tests\test4\Блок развития и поддержки АБС\Каримова Альбина Ринатовна (00138841).xlsx
tests\test4\Блок развития и поддержки АБС\Кот Екатерина Юрьевна (00137688).xlsx
tests\test4\Блок развития и поддержки АБС\Кочихина Яна Сергеевна (00197511).xlsx
tests\test4\Блок развития и поддержки АБС\Кочубей Неля Александровна (00091370).xlsx
tests\test4\Блок развития и поддержки АБС\Кречетов Павел Валерьевич (00169558).xlsx
tests\test4\Блок развития и поддержки АБС\Кудрина Кристина Владимировна (00214497).xlsx
tests\test4\Блок развития и поддержки АБС\Лужецкая Бэла Леонидовна (00155603).xlsx
tests\test4\Блок развития и поддержки АБС\Мокин Роман Александрович (00135622).xlsx
tests\test4\Блок развития и поддержки АБС\Муранова Ирина Олеговна (00140293).xlsx
tests\test4\Блок развития и поддержки АБС\Отчет по блоку_Блок развития и поддержки АБС_20250715_102239.xlsx
tests\test4\Блок развития и поддержки АБС\Рафиков Алмаз Минихамитович (00107667).xlsx
tests\test4\Блок развития и поддержки АБС\Старцев Евгений Сергеевич (00116286).xlsx
tests\test4\Блок развития и поддержки АБС\Трубаков Александр Владимирович (00155775).xlsx
tests\test4\Блок цифровой трансформации\Бароян Анжела Гайковна (00116117).xlsx
tests\test4\Блок цифровой трансформации\Вакулина Ольга Сергеевна (00218208).xlsx
tests\test4\Блок цифровой трансформации\Валеев Станислав Салаватович (00150639).xlsx
tests\test4\Блок цифровой трансформации\Зуев Павел Сергеевич (00197754).xlsx
tests\test4\Блок цифровой трансформации\Отчет по блоку_Блок цифровой трансформации_20250715_102242.xlsx
tests\test4\Блок цифровой трансформации\Стрелкова Дарья Сергеевна (00216772).xlsx
tests\test4\Блок цифровой трансформации\Фоминых Артём Владимирович (00218402).xlsx
tests\test4\Блок цифровой трансформации\Эшмирзаев Жасур Сайфиддинович (00137074).xlsx
__pycache__\config.cpython-311.pyc
__pycache__\models.cpython-311.pyc


###############################################
### PYTHON FILES CONTENT
###############################################


=============================================
FILE: D:\Users\chernousov-am\vp on pt\config.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Модуль конфигурации приложения
"""

import json
import logging
from pathlib import Path
from typing import Dict, Any


class Config:
    """Класс для управления конфигурацией приложения"""
    
    DEFAULT_CONFIG = {
        "employee_template": "templates/employee_template.xlsx",
        "block_report_template": "templates/block_report_template.xlsx", 
        "general_report_template": "templates/global_report_template.xlsx",
        "header_row": 5,
        "processing_time_per_file": 0.3,
        "excel_password": "1111",
        "date_format": "%d.%m.%y",
        "max_employees": 10000,
        "min_employees": 1,
        "window_width": 1000,
        "window_height": 700
    }
    
    def __init__(self, config_file: str = "config.json"):
        self.config_file = Path(config_file)
        self.data = self.DEFAULT_CONFIG.copy()
        self.logger = logging.getLogger(__name__)
    
    def load_or_create_default(self) -> None:
        """Загружает конфигурацию из файла или создает файл по умолчанию"""
        try:
            if self.config_file.exists():
                self.load()
                self.logger.info(f"Конфигурация загружена из {self.config_file}")
            else:
                self.save()
                self.logger.info(f"Создан файл конфигурации по умолчанию: {self.config_file}")
        except Exception as e:
            self.logger.error(f"Ошибка работы с конфигурацией: {e}")
            self.data = self.DEFAULT_CONFIG.copy()
    
    def load(self) -> None:
        """Загружает конфигурацию из файла"""
        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                loaded_data = json.load(f)
                
            # Обновляем только существующие ключи, остальные берем из DEFAULT_CONFIG
            for key, value in loaded_data.items():
                if key in self.DEFAULT_CONFIG:
                    self.data[key] = value
                    
        except FileNotFoundError:
            self.logger.warning(f"Файл конфигурации не найден: {self.config_file}")
            raise
        except json.JSONDecodeError as e:
            self.logger.error(f"Ошибка парсинга JSON: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Ошибка загрузки конфигурации: {e}")
            raise
    
    def save(self) -> None:
        """Сохраняет конфигурацию в файл"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.error(f"Ошибка сохранения конфигурации: {e}")
            raise
    
    def get(self, key: str, default=None):
        """Получает значение из конфигурации"""
        return self.data.get(key, default)
    
    def set(self, key: str, value: Any) -> None:
        """Устанавливает значение в конфигурации"""
        self.data[key] = value
    
    def validate_templates(self) -> Dict[str, bool]:
        """Проверяет наличие шаблонов"""
        templates = {
            "employee_template": self.get("employee_template"),
            "block_report_template": self.get("block_report_template"),
            "general_report_template": self.get("general_report_template")
        }
        
        results = {}
        for name, path in templates.items():
            file_path = Path(path)
            results[name] = file_path.exists()
            
        return results
    
    @property
    def employee_template(self) -> str:
        return self.get("employee_template")
    
    @property 
    def block_report_template(self) -> str:
        return self.get("block_report_template")
    
    @property
    def general_report_template(self) -> str:
        return self.get("general_report_template")
    
    @property
    def header_row(self) -> int:
        return self.get("header_row", 5)
    
    @property
    def excel_password(self) -> str:
        return self.get("excel_password", "1111")
    
    @property
    def date_format(self) -> str:
        return self.get("date_format", "%d.%m.%y")
    
    @property
    def max_employees(self) -> int:
        return self.get("max_employees", 10000)
    
    @property
    def min_employees(self) -> int:
        return self.get("min_employees", 1)



=============================================
FILE: D:\Users\chernousov-am\vp on pt\create_report.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Создание отчета по блоку - Автономный скрипт
Использует файлы сотрудников в текущей папке для создания отчета по подразделению
"""

import os
import sys
import time
import shutil
from pathlib import Path
from datetime import datetime, date
from typing import List, Optional, Dict
import re

try:
    import openpyxl
    from openpyxl.styles import PatternFill, Border, Side
    from openpyxl.utils import get_column_letter
except ImportError:
    print("ОШИБКА: Не установлена библиотека openpyxl")
    print("Установите: pip install openpyxl")
    input("Нажмите Enter для выхода...")
    sys.exit(1)


class Employee:
    """Простая модель сотрудника"""
    def __init__(self):
        self.full_name = ""
        self.tab_number = ""
        self.position = ""
        self.department1 = ""
        self.department2 = ""
        self.department3 = ""
        self.department4 = ""


class VacationPeriod:
    """Период отпуска"""
    def __init__(self, start_date: date, end_date: date, days: int = 0):
        self.start_date = start_date
        self.end_date = end_date
        self.days = days if days > 0 else (end_date - start_date).days + 1


class VacationInfo:
    """Информация об отпусках сотрудника"""
    def __init__(self, employee: Employee, periods: List[VacationPeriod] = None):
        self.employee = employee
        self.periods = periods or []
        self.total_days = sum(period.days for period in self.periods)
        self.periods_count = len(self.periods)
        self.has_long_period = any(period.days >= 14 for period in self.periods)
        self.validation_errors = []
        
        # Определяем статус
        if not self.periods:
            self.status = "Не заполнено"
        elif self.validation_errors:
            self.status = "Ошибка"
        elif self.total_days >= 28 and self.has_long_period:
            self.status = "Ок"
        else:
            self.status = "Частично"


class BlockReportCreator:
    """Создатель отчетов по блокам"""
    
    # Константы для 2026 года
    DAYS_IN_MONTH_2026 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    MONTH_NAMES = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 
                   'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']
    
    def __init__(self):
        self.template_path = r"M:\Подразделения\АУП\Стажерская программа\Отпуск Р7\templates\block_report_template.xlsx"
        
    def validate_template(self) -> bool:
        """Проверяет наличие шаблона"""
        if not Path(self.template_path).exists():
            print(f"ОШИБКА: Шаблон не найден по пути: {self.template_path}")
            return False
        print(f"✓ Шаблон найден")
        return True
    
    def scan_employee_files(self, directory: str) -> List[str]:
        """Сканирует файлы сотрудников в папке"""
        employee_files = []
        directory_path = Path(directory)
        
        print(f"Сканирование папки: {directory_path.absolute()}")
        
        for file_path in directory_path.iterdir():
            if not file_path.is_file() or file_path.suffix.lower() != '.xlsx':
                continue
            
            filename = file_path.name
            
            # Исключаем отчеты и системные файлы
            if (filename.startswith('~') or 
                filename.startswith('!') or
                filename.startswith('Отчет') or
                filename.startswith('отчет') or
                filename.startswith('ОБЩИЙ') or
                'report' in filename.lower()):
                continue
            
            employee_files.append(str(file_path))
        
        print(f"✓ Найдено файлов сотрудников: {len(employee_files)}")
        return employee_files
    
    def parse_date(self, date_value) -> Optional[date]:
        """Парсит дату из различных форматов"""
        if not date_value:
            return None
        
        # Если уже date или datetime
        if isinstance(date_value, date):
            return date_value
        if isinstance(date_value, datetime):
            return date_value.date()
        
        # Если строка
        date_str = str(date_value).strip()
        if not date_str:
            return None
        
        # Попробуем различные форматы
        formats = ["%d.%m.%Y", "%d.%m.%y", "%Y-%m-%d", "%d/%m/%Y", "%d/%m/%y"]
        
        for fmt in formats:
            try:
                parsed_date = datetime.strptime(date_str, fmt).date()
                return parsed_date
            except ValueError:
                continue
        
        return None
    
    def get_cell_value(self, worksheet, cell_address: str):
        """Безопасно получает значение ячейки"""
        try:
            cell = worksheet[cell_address]
            return cell.value
        except Exception:
            return None
    
    def read_vacation_info_from_file(self, file_path: str) -> Optional[VacationInfo]:
        """Читает информацию об отпусках из файла сотрудника"""
        try:
            workbook = openpyxl.load_workbook(file_path, data_only=True)
            worksheet = workbook.active
            
            # Читаем базовую информацию о сотруднике
            employee = Employee()
            
            # Ищем первую заполненную строку для получения базовой информации (строки 9-23)
            for row in range(9, 24):
                tab_number = self.get_cell_value(worksheet, f"B{row}")
                full_name = self.get_cell_value(worksheet, f"C{row}")
                position = self.get_cell_value(worksheet, f"D{row}")
                
                if tab_number and full_name:
                    employee.tab_number = str(tab_number).strip()
                    employee.full_name = str(full_name).strip()
                    if position:
                        employee.position = str(position).strip()
                    break
            
            # Читаем подразделения из шапки файла (C2:C5)
            employee.department1 = str(self.get_cell_value(worksheet, "C2") or "").strip()
            employee.department2 = str(self.get_cell_value(worksheet, "C3") or "").strip()
            employee.department3 = str(self.get_cell_value(worksheet, "C4") or "").strip()
            employee.department4 = str(self.get_cell_value(worksheet, "C5") or "").strip()
            
            # Читаем периоды отпусков из строк 9-23
            periods = []
            
            for row in range(9, 24):
                start_date_value = self.get_cell_value(worksheet, f"E{row}")
                end_date_value = self.get_cell_value(worksheet, f"F{row}")
                days_value = self.get_cell_value(worksheet, f"G{row}")
                
                if not start_date_value or not end_date_value:
                    continue
                
                try:
                    # Парсим даты
                    start_date = self.parse_date(start_date_value)
                    end_date = self.parse_date(end_date_value)
                    
                    if not start_date or not end_date:
                        continue
                    
                    # Парсим количество дней
                    days = 0
                    if days_value:
                        try:
                            days = int(days_value)
                        except (ValueError, TypeError):
                            days = (end_date - start_date).days + 1
                    else:
                        days = (end_date - start_date).days + 1
                    
                    period = VacationPeriod(start_date=start_date, end_date=end_date, days=days)
                    periods.append(period)
                    
                except Exception as e:
                    print(f"ПРЕДУПРЕЖДЕНИЕ: Ошибка обработки периода в строке {row}: {e}")
                    continue
            
            # Читаем результаты валидации
            validation_h2 = str(self.get_cell_value(worksheet, "H2") or "").strip()
            validation_i2 = str(self.get_cell_value(worksheet, "I2") or "").strip()
            validation_j2 = self.get_cell_value(worksheet, "J2") or 0
            
            # Создаем VacationInfo
            vacation_info = VacationInfo(employee=employee, periods=periods)
            
            # Определяем статус на основе валидаций
            if "ОШИБКА" in validation_h2:
                vacation_info.validation_errors.append(validation_h2)
            
            if "ОШИБКА" in validation_i2:
                vacation_info.validation_errors.append(validation_i2)
            
            try:
                total_days = int(validation_j2) if validation_j2 else 0
                if total_days < 28:
                    vacation_info.validation_errors.append(f"ОШИБКА: Недостаточно дней отпуска. Запланировано {total_days} дней, требуется минимум 28.")
            except (ValueError, TypeError):
                vacation_info.validation_errors.append("ОШИБКА: Не удалось определить общее количество дней отпуска.")
            
            # Обновляем статус
            if not vacation_info.validation_errors:
                vacation_info.status = "Ок"
            else:
                vacation_info.status = "Ошибка"
            
            workbook.close()
            return vacation_info
            
        except Exception as e:
            print(f"ОШИБКА: Не удалось прочитать файл {file_path}: {e}")
            return None
    
    def get_calendar_column(self, target_date: date, start_col: int) -> Optional[int]:
        """Вычисляет номер столбца для конкретной даты в календарной матрице"""
        if target_date.year != 2026:
            return None
        
        col_offset = 0
        # Считаем смещение по месяцам
        for month in range(1, target_date.month):
            col_offset += self.DAYS_IN_MONTH_2026[month - 1]
        
        # Добавляем день месяца
        col_offset += target_date.day - 1
        
        return start_col + col_offset
    
    def fill_calendar_matrix(self, worksheet, vacation_infos: List[VacationInfo]):
        """Заполняет календарную матрицу на листе Report"""
        try:
            start_col = 12  # Столбец L
            
            # Заполняем месяца в строке 7
            col_offset = 0
            for month_idx, month_name in enumerate(self.MONTH_NAMES):
                month_col = start_col + col_offset
                worksheet.cell(row=7, column=month_col, value=month_name)
                
                # Заполняем дни месяца в строке 8
                days_in_month = self.DAYS_IN_MONTH_2026[month_idx]
                for day in range(1, days_in_month + 1):
                    day_col = start_col + col_offset + day - 1
                    worksheet.cell(row=8, column=day_col, value=day)
                
                col_offset += days_in_month
            
            # Заполняем отпуска для каждого сотрудника
            for emp_idx, vacation_info in enumerate(vacation_infos):
                emp_row = emp_idx + 9  # Строка сотрудника
                
                for period in vacation_info.periods:
                    # Заполняем дни отпуска единицами
                    current_date = period.start_date
                    while current_date <= period.end_date:
                        if current_date.year == 2026:  # Только для 2026 года
                            day_col = self.get_calendar_column(current_date, start_col)
                            if day_col:
                                worksheet.cell(row=emp_row, column=day_col, value=1)
                        
                        # Переход к следующему дню
                        from datetime import timedelta
                        current_date = current_date + timedelta(days=1)
                        
                        if current_date > period.end_date:
                            break
                            
        except Exception as e:
            print(f"ОШИБКА: Ошибка заполнения календарной матрицы: {e}")
    
    def create_block_report(self, block_name: str, vacation_infos: List[VacationInfo], output_path: str) -> bool:
        """Создает отчет по блоку с календарной матрицей"""
        try:
            # Копируем шаблон
            shutil.copy2(self.template_path, output_path)
            
            # Открываем файл для заполнения
            workbook = openpyxl.load_workbook(output_path)
            
            # Заполняем лист Report
            self.fill_report_sheet(workbook, block_name, vacation_infos)
            
            # Заполняем лист Print
            self.fill_print_sheet(workbook, block_name, vacation_infos)
            
            workbook.save(output_path)
            workbook.close()
            
            print(f"✓ Отчет создан: {output_path}")
            return True
            
        except Exception as e:
            print(f"ОШИБКА: Ошибка создания отчета по блоку {block_name}: {e}")
            return False
    
    def fill_report_sheet(self, workbook, block_name: str, vacation_infos: List[VacationInfo]):
        """Заполняет лист Report"""
        if 'Report' not in workbook.sheetnames:
            print("ОШИБКА: Лист 'Report' не найден в шаблоне")
            return
        
        worksheet = workbook['Report']
        current_time = datetime.now()
        
        # Шапка A3:A6
        worksheet["A3"] = block_name
        worksheet["A4"] = f"Дата обновления: {current_time.strftime('%d.%m.%Y %H:%M')}"
        worksheet["A5"] = f"Количество сотрудников: {len(vacation_infos)}"
        
        # Подсчет завершивших планирование
        completed = sum(1 for vi in vacation_infos if vi.status == "Ок")
        percentage = (completed / len(vacation_infos) * 100) if vacation_infos else 0
        worksheet["A6"] = f"Закончили планирование: {completed} ({percentage:.0f}%)"
        
        # Заполняем таблицу сотрудников (начиная с строки 9)
        for i, vacation_info in enumerate(vacation_infos):
            row = i + 9
            emp = vacation_info.employee
            
            worksheet[f"A{row}"] = i + 1  # №
            worksheet[f"B{row}"] = emp.full_name  # ФИО
            worksheet[f"C{row}"] = emp.tab_number  # Таб. Номер
            worksheet[f"D{row}"] = emp.position  # Должность
            worksheet[f"E{row}"] = emp.department1  # Подразделение 1
            worksheet[f"F{row}"] = emp.department2  # Подразделение 2
            worksheet[f"G{row}"] = emp.department3  # Подразделение 3
            worksheet[f"H{row}"] = emp.department4  # Подразделение 4
            
            # Статус планирования
            if vacation_info.status == "Ок":
                worksheet[f"I{row}"] = "Ок"
            else:
                errors = vacation_info.validation_errors
                worksheet[f"I{row}"] = "\n".join(errors) if errors else "Ошибка"
            
            worksheet[f"J{row}"] = vacation_info.total_days  # Итого дней
            worksheet[f"K{row}"] = vacation_info.periods_count  # Кол-во периодов
            
            # Добавляем границы
            thin_border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )

            # Применить границы к диапазону строки (столбцы A-K + календарь)
            for col in range(1, 378):  # A до столбца календаря
                worksheet.cell(row=row, column=col).border = thin_border
        
        # Заполняем календарную матрицу
        self.fill_calendar_matrix(worksheet, vacation_infos)
    
    def fill_print_sheet(self, workbook, block_name: str, vacation_infos: List[VacationInfo]):
        """Заполняет лист Print в нормализованном виде"""
        if 'Print' not in workbook.sheetnames:
            print("ОШИБКА: Лист 'Print' не найден в шаблоне")
            return
        
        worksheet = workbook['Print']
        
        # D4 - название блока
        worksheet["D4"] = block_name
        
        # Нормализуем данные - каждый период отпуска = отдельная строка
        normalized_data = []
        for vacation_info in vacation_infos:
            emp = vacation_info.employee
            
            if not vacation_info.periods:
                # Если нет периодов, добавляем пустую строку
                normalized_data.append({
                    'employee': emp,
                    'period_num': 0,
                    'start_date': None,
                    'end_date': None,
                    'days': 0
                })
            else:
                # Добавляем строку для каждого периода
                for period_idx, period in enumerate(vacation_info.periods, 1):
                    normalized_data.append({
                        'employee': emp,
                        'period_num': period_idx,
                        'start_date': period.start_date,
                        'end_date': period.end_date,
                        'days': period.days
                    })
        
        # Заполняем данные с учетом разбивки по страницам
        current_row = 9  # Начинаем с 9 строки
        records_on_page = 0
        max_records_first_page = 14
        max_records_other_pages = 18
        is_first_page = True
        
        for record_idx, record in enumerate(normalized_data):
            # Проверяем нужность новой страницы
            max_records = max_records_first_page if is_first_page else max_records_other_pages
            
            if records_on_page >= max_records:
                # Добавляем заголовки на новой странице
                current_row += 1  # Пропускаем строку
                self.add_print_headers(worksheet, current_row)
                current_row += 1
                records_on_page = 0
                is_first_page = False
            
            # Заполняем строку данных
            emp = record['employee']
            
            worksheet[f"A{current_row}"] = record_idx + 1  # № п/п
            worksheet[f"B{current_row}"] = emp.tab_number  # Табельный номер
            worksheet[f"C{current_row}"] = emp.full_name  # ФИО
            worksheet[f"D{current_row}"] = emp.position  # Должность
            
            if record['start_date']:
                worksheet[f"E{current_row}"] = record['start_date'].strftime('%d.%m.%Y')  # Дата начала
                worksheet[f"F{current_row}"] = record['end_date'].strftime('%d.%m.%Y')  # Дата окончания
                worksheet[f"G{current_row}"] = record['days']  # Продолжительность
            
            current_row += 1
            records_on_page += 1
    
    def add_print_headers(self, worksheet, row: int):
        """Добавляет заголовки таблицы для печати"""
        headers = [
            "№ п/п", "Табельный номер", "ФИО", "Должность",
            "Дата начала отпуска", "Дата окончания отпуска",
            "Продолжительность (календарных дней)",
            "Подпись работника", "Дата ознакомления работника", "Примечание"
        ]
        
        for col_idx, header in enumerate(headers, 1):
            worksheet.cell(row=row, column=col_idx, value=header)


def main():
    """Главная функция скрипта"""
    print("=" * 60)
    print("  СОЗДАНИЕ ОТЧЕТА ПО БЛОКУ")
    print("  Автономный скрипт для создания отчетов по подразделениям")
    print("=" * 60)
    print()
    
    creator = BlockReportCreator()
    
    # 1. Проверяем шаблон
    print("1. Проверка шаблона...")
    if not creator.validate_template():
        input("Нажмите Enter для выхода...")
        return
    
    # 2. Определяем текущую папку
    current_dir = os.getcwd()
    print(f"2. Текущая папка: {current_dir}")
    
    # 3. Сканируем файлы сотрудников
    print("3. Поиск файлов сотрудников...")
    employee_files = creator.scan_employee_files(current_dir)
    
    if not employee_files:
        print("ОШИБКА: В текущей папке не найдено файлов сотрудников (.xlsx)")
        input("Нажмите Enter для выхода...")
        return
    
    # 4. Читаем данные из файлов
    print("4. Чтение данных из файлов...")
    vacation_infos = []
    invalid_files = []
    
    for i, file_path in enumerate(employee_files, 1):
        print(f"   Обработка {i}/{len(employee_files)}: {Path(file_path).name}")
        vacation_info = creator.read_vacation_info_from_file(file_path)
        
        if vacation_info:
            vacation_infos.append(vacation_info)
        else:
            invalid_files.append(Path(file_path).name)
    
    if not vacation_infos:
        print("ОШИБКА: Не удалось прочитать ни одного файла сотрудника")
        input("Нажмите Enter для выхода...")
        return
    
    print(f"✓ Успешно обработано файлов: {len(vacation_infos)} из {len(employee_files)}")
    
    if invalid_files:
        print(f"Сотрудников с неверно заполненным файлом: {len(invalid_files)}")
        for invalid_file in invalid_files:
            print(f"   • {invalid_file}")
    
    # 5. Определяем название блока из первого сотрудника
    block_name = vacation_infos[0].employee.department1 or "Неизвестное подразделение"
    print(f"5. Название блока: {block_name}")
    
    # 6. Создаем отчет
    print("6. Создание отчета...")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = f"Отчет по блоку_{block_name}_{timestamp}.xlsx"
    
    # Очищаем имя файла от недопустимых символов
    invalid_chars = r'[\\/:*?"<>|]'
    output_filename = re.sub(invalid_chars, '_', output_filename)
    output_path = Path(current_dir) / output_filename
    
    success = creator.create_block_report(block_name, vacation_infos, str(output_path))
    
    if success:
        print()
        print("=" * 60)
        print("  ОТЧЕТ УСПЕШНО СОЗДАН!")
        print("=" * 60)
        print(f"Файл: {output_filename}")
        print(f"Подразделение: {block_name}")
        print(f"Сотрудников: {len(vacation_infos)}")
        
        # Статистика по статусам с детализацией ошибок
        status_counts = {}
        error_types = {}
        
        for vi in vacation_infos:
            status = vi.status
            status_counts[status] = status_counts.get(status, 0) + 1
            
            # Детализация ошибок
            if vi.validation_errors:
                for error in vi.validation_errors:
                    if "Недостаточно дней отпуска" in error:
                        error_types["Недостаточно дней отпуска"] = error_types.get("Недостаточно дней отпуска", 0) + 1
                    elif "пересечение периодов" in error.lower():
                        error_types["Пересечение периодов"] = error_types.get("Пересечение периодов", 0) + 1
                    elif "Не удалось определить" in error:
                        error_types["Проблемы с подсчетом дней"] = error_types.get("Проблемы с подсчетом дней", 0) + 1
                    else:
                        error_types["Прочие ошибки"] = error_types.get("Прочие ошибки", 0) + 1
        
        print("Статистика планирования:")
        for status, count in status_counts.items():
            print(f"  {status}: {count}")
        
        if error_types:
            print("Типы ошибок:")
            for error_type, count in error_types.items():
                print(f"  {error_type}: {count}")
        
        print()
        print("Отчет создан в текущей папке.")
    else:
        print("ОШИБКА: Не удалось создать отчет")
    
    print()
    input("Нажмите Enter для выхода...")


if __name__ == "__main__":
    main()



=============================================
FILE: D:\Users\chernousov-am\vp on pt\main.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Vacation Tool - Главный модуль
Приложение для управления отпусками сотрудников
"""

import sys
import os
import logging
from pathlib import Path
import tkinter as tk
from tkinter import messagebox
import warnings

# Убираем предупреждения
warnings.filterwarnings("ignore")

# Показываем консоль при запуске для обратной связи
if getattr(sys, 'frozen', False):
    # Запуск из exe - показываем что загружается
    print("Запуск Vacation Tool...")
    print("Загрузка интерфейса...")
    # Устанавливаем рабочую папку
    application_path = os.path.dirname(sys.executable)
    os.chdir(application_path)
else:
    # Режим разработки
    application_path = os.path.dirname(os.path.abspath(__file__))

# Добавляем текущую папку в sys.path для импорта модулей
if __name__ == "__main__":
    current_dir = Path(__file__).parent
    sys.path.insert(0, str(current_dir))

from config import Config
from gui.main_window import MainWindow

def setup_logging():
    """Настройка логирования только в консоль"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )


def main():
    """Главная функция приложения"""
    try:
        # В exe показываем прогресс
        if getattr(sys, 'frozen', False):
            print("Настройка логирования...")
        
        # Настройка логирования
        setup_logging()
        logger = logging.getLogger(__name__)
        logger.info("Запуск Vacation Tool...")
        
        if getattr(sys, 'frozen', False):
            print(" Загрузка конфигурации...")
        
        # Загрузка конфигурации
        config = Config()
        config.load_or_create_default()
        
        if getattr(sys, 'frozen', False):
            print(" Создание интерфейса...")
        
        # Создание и запуск GUI
        root = tk.Tk()
        root.title("Vacation Tool v1.0 - Управление отпусками")
        root.geometry("750x500")
        root.resizable(False, False)
        
        # Создание главного окна
        app = MainWindow(root, config)
        
        # Обработка закрытия окна
        def on_closing():
            logger.info("Завершение работы приложения")
            root.destroy()
        
        root.protocol("WM_DELETE_WINDOW", on_closing)
        
        if getattr(sys, 'frozen', False):
            print("Готово! Открываем приложение...")
            # Небольшая задержка чтобы пользователь увидел что все загрузилось
            root.after(1500, lambda: None)  # Консоль закроется через 1.5 сек
        
        # Запуск главного цикла
        logger.info("GUI запущен")
        root.mainloop()
        
    except Exception as e:
        error_msg = f"Критическая ошибка: {e}"
        logging.error(error_msg, exc_info=True)
        
        # Показываем ошибку пользователю
        try:
            messagebox.showerror("Ошибка", error_msg)
        except:
            print(error_msg)
        
        sys.exit(1)


if __name__ == "__main__":
    main()



=============================================
FILE: D:\Users\chernousov-am\vp on pt\models.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Модели данных для приложения Vacation Tool
"""

from dataclasses import dataclass, field
from datetime import datetime, date
from typing import List, Optional, Dict, Any
from enum import Enum


class VacationStatus(Enum):
    """Статусы планирования отпуска"""
    OK = "Ок"
    PARTIAL = "Частично"
    EMPTY = "Не заполнено"
    ERROR = "Ошибка"


class ProcessingStatus(Enum):
    """Статусы обработки"""
    SUCCESS = "SUCCESS"
    ERROR = "ERROR"
    CANCELLED = "CANCELLED"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"  # Добавляем статус завершения


@dataclass
class Employee:
    """Модель сотрудника"""
    full_name: str = ""
    tab_number: str = ""
    position: str = ""  # Должность
    department1: str = ""
    department2: str = ""
    department3: str = ""
    department4: str = ""
    file_path: str = ""
    
    # Новые поля
    location: str = ""  # Локация сотрудника
    vacation_remainder: str = ""  # Остатки отпуска сотрудника за прошлый период
    hire_date: str = ""  # Дата приема сотрудника
    period_cutoff_date: str = ""  # Дата отсечки периода
    additional_vacation_nrd: str = ""  # Дополнительный отпуск за НРД
    additional_vacation_north: str = ""  # Дополнительный отпуск Северный
    
    def __post_init__(self):
        # Очистка строк от лишних пробелов
        self.full_name = self.full_name.strip()
        self.tab_number = self.tab_number.strip()
        self.position = self.position.strip()
        self.department1 = self.department1.strip()
        self.department2 = self.department2.strip()
        self.department3 = self.department3.strip()
        self.department4 = self.department4.strip()
        self.location = self.location.strip()
        self.vacation_remainder = self.vacation_remainder.strip()
        self.hire_date = self.hire_date.strip()
        self.period_cutoff_date = self.period_cutoff_date.strip()
        self.additional_vacation_nrd = self.additional_vacation_nrd.strip()
        self.additional_vacation_north = self.additional_vacation_north.strip()


@dataclass
class VacationPeriod:
    """Период отпуска"""
    start_date: date
    end_date: date
    days: int = 0
    
    def __post_init__(self):
        if self.days == 0:
            self.days = (self.end_date - self.start_date).days + 1


@dataclass
class VacationInfo:
    """Информация об отпусках сотрудника"""
    employee: Employee
    periods: List[VacationPeriod] = field(default_factory=list)
    total_days: int = 0
    status: VacationStatus = VacationStatus.EMPTY
    periods_count: int = 0
    has_long_period: bool = False  # Есть ли период >= 14 дней
    validation_errors: List[str] = field(default_factory=list)  # Ошибки валидации
    
    def __post_init__(self):
        self.periods_count = len(self.periods)
        self.total_days = sum(period.days for period in self.periods)
        self.has_long_period = any(period.days >= 14 for period in self.periods)
        self._update_status()
    
    def _update_status(self):
        """Обновляет статус на основе данных"""
        if not self.periods:
            self.status = VacationStatus.EMPTY
        elif self.validation_errors:
            self.status = VacationStatus.ERROR
        elif self.total_days >= 28 and self.has_long_period:
            self.status = VacationStatus.OK
        else:
            self.status = VacationStatus.PARTIAL


@dataclass
class BlockReport:
    """Отчет по блоку/подразделению"""
    block_name: str
    employees: List[VacationInfo] = field(default_factory=list)
    total_employees: int = 0
    status_ok: int = 0
    status_partial: int = 0
    status_empty: int = 0
    status_error: int = 0  # Добавляем подсчет ошибок
    average_days: float = 0.0
    completion_percentage: float = 0.0
    
    def __post_init__(self):
        self.total_employees = len(self.employees)
        self._calculate_statistics()
    
    def _calculate_statistics(self):
        """Вычисляет статистику блока"""
        if not self.employees:
            return
            
        status_counts = {status: 0 for status in VacationStatus}
        total_days = 0
        
        for emp in self.employees:
            status_counts[emp.status] += 1
            total_days += emp.total_days
        
        self.status_ok = status_counts[VacationStatus.OK]
        self.status_partial = status_counts[VacationStatus.PARTIAL]
        self.status_empty = status_counts[VacationStatus.EMPTY]
        self.status_error = status_counts[VacationStatus.ERROR]
        
        self.average_days = total_days / self.total_employees if self.total_employees > 0 else 0
        self.completion_percentage = (self.status_ok / self.total_employees * 100) if self.total_employees > 0 else 0


@dataclass
class GeneralReport:
    """Общий отчет по всем блокам"""
    block_reports: List[BlockReport] = field(default_factory=list)
    total_employees: int = 0
    status_ok: int = 0
    status_partial: int = 0
    status_empty: int = 0
    status_error: int = 0
    average_days: float = 0.0
    average_periods: float = 0.0
    completion_percentage: float = 0.0
    generated_at: datetime = field(default_factory=datetime.now)
    
    def __post_init__(self):
        self._calculate_totals()
    
    def _calculate_totals(self):
        """Вычисляет общую статистику"""
        if not self.block_reports:
            return
        
        self.total_employees = sum(block.total_employees for block in self.block_reports)
        self.status_ok = sum(block.status_ok for block in self.block_reports)
        self.status_partial = sum(block.status_partial for block in self.block_reports)
        self.status_empty = sum(block.status_empty for block in self.block_reports)
        self.status_error = sum(block.status_error for block in self.block_reports)
        
        if self.total_employees > 0:
            total_days = sum(block.average_days * block.total_employees for block in self.block_reports)
            self.average_days = total_days / self.total_employees
            
            total_periods = sum(
                sum(emp.periods_count for emp in block.employees) 
                for block in self.block_reports
            )
            self.average_periods = total_periods / self.total_employees
            
            self.completion_percentage = self.status_ok / self.total_employees * 100


@dataclass
class ValidationResult:
    """Результат валидации"""
    is_valid: bool = True
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    employee_count: int = 0
    unique_tab_numbers: int = 0
    processing_time: float = 0.0
    
    def add_error(self, message: str):
        """Добавляет ошибку"""
        self.errors.append(message)
        self.is_valid = False
    
    def add_warning(self, message: str):
        """Добавляет предупреждение"""
        self.warnings.append(message)


@dataclass
class ProcessingProgress:
    """Прогресс обработки"""
    current_operation: str = ""
    current_file: str = ""
    processed_files: int = 0
    total_files: int = 0
    current_block: str = ""
    processed_blocks: int = 0
    total_blocks: int = 0
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    elapsed_time: float = 0.0
    estimated_time: float = 0.0
    speed: float = 0.0  # файлов в секунду
    status: ProcessingStatus = ProcessingStatus.IN_PROGRESS
    error_message: str = ""
    
    @property
    def file_progress_percent(self) -> float:
        """Процент выполнения по файлам"""
        if self.total_files == 0:
            return 0.0
        return (self.processed_files / self.total_files) * 100
    
    @property
    def block_progress_percent(self) -> float:
        """Процент выполнения по блокам"""
        if self.total_blocks == 0:
            return 0.0
        return (self.processed_blocks / self.total_blocks) * 100


@dataclass
class LogEntry:
    """Запись в логе операции"""
    timestamp: datetime
    level: str  # INFO, WARN, ERROR
    operation: str
    message: str
    details: str = ""


@dataclass
class OperationLog:
    """Лог операции"""
    operation_name: str
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    entries: List[LogEntry] = field(default_factory=list)
    status: ProcessingStatus = ProcessingStatus.IN_PROGRESS
    
    def add_entry(self, level: str, message: str, details: str = ""):
        """Добавляет запись в лог"""
        entry = LogEntry(
            timestamp=datetime.now(),
            level=level,
            operation=self.operation_name,
            message=message,
            details=details
        )
        self.entries.append(entry)
    
    def finish(self, status: ProcessingStatus):
        """Завершает операцию"""
        self.end_time = datetime.now()
        self.status = status
    
    @property
    def duration(self) -> float:
        """Длительность операции в секундах"""
        if self.end_time is None:
            return (datetime.now() - self.start_time).total_seconds()
        return (self.end_time - self.start_time).total_seconds()



=============================================
FILE: D:\Users\chernousov-am\vp on pt\core\excel_handler.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Модуль работы с Excel файлами
"""

import logging
import shutil
from pathlib import Path
from datetime import datetime, date
from typing import List, Optional, Dict, Tuple
import re

import openpyxl
from openpyxl.styles import Border, Side

from models import Employee, VacationInfo, VacationPeriod, VacationStatus
from config import Config


class ExcelHandler:
    """Класс для работы с Excel файлами"""
    
    # Константы для 2026 года (не високосный)
    DAYS_IN_MONTH_2026 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    MONTH_NAMES = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 
                   'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']
    
    def __init__(self, config: Config):
        self.config = config
        self.logger = logging.getLogger(__name__)

    def _parse_cell_address(self, address: str) -> Tuple[bool, str, Optional[str]]:
        """Парсит адрес ячейки"""
        address = address.strip()
        
        if address.startswith('#'):
            raise ValueError(f"Недопустимый адрес ячейки: {address}")
        
        if address.startswith('='):
            clean_address = address[1:]
            if '!' in clean_address:
                parts = clean_address.split('!')
                if len(parts) != 2:
                    raise ValueError(f"Неверный формат ссылки: {address}")
                sheet_name = parts[0].strip("'\"")
                cell_ref = parts[1]
                return True, cell_ref, sheet_name
            else:
                return True, clean_address, None
        else:
            return False, address, None

    def _fill_cell_or_range(self, workbook, sheet_name: Optional[str], cell_ref: str, value: any):
        """Заполняет ячейку или диапазон значением"""
        worksheet = workbook[sheet_name] if sheet_name and sheet_name in workbook.sheetnames else workbook.active
        
        if ';' in cell_ref:
            for single_ref in cell_ref.split(';'):
                single_ref = single_ref.strip()
                if single_ref:
                    worksheet[single_ref] = value
        elif ':' in cell_ref:
            cell_range = worksheet[cell_ref]
            if hasattr(cell_range, '__iter__'):
                for row in cell_range:
                    if hasattr(row, '__iter__'):
                        for cell in row:
                            cell.value = value
                    else:
                        row.value = value
            else:
                cell_range.value = value
        else:
            worksheet[cell_ref] = value

    def _load_filling_rules(self, template_path: str) -> Dict[str, Dict[str, str]]:
        """Загружает правила заполнения из листа 'rules'"""
        rules = {'value': {}, 'header': {}}
        
        workbook = openpyxl.load_workbook(template_path, data_only=False)
        
        if 'rules' not in workbook.sheetnames:
            workbook.close()
            raise ValueError(f"Лист 'rules' не найден в шаблоне {template_path}")
        
        rules_sheet = workbook['rules']
        
        for row in range(2, rules_sheet.max_row + 1):
            source_cell = rules_sheet.cell(row=row, column=1)
            target_cell = rules_sheet.cell(row=row, column=2)
            type_cell = rules_sheet.cell(row=row, column=3)
            
            source_address = source_cell.value if source_cell.data_type == 'f' else source_cell.value
            target_field = target_cell.value
            rule_type = type_cell.value
            
            if source_address and target_field and rule_type:
                source_address = str(source_address).strip()
                target_field = str(target_field).strip()
                rule_type = str(rule_type).strip().lower()
                
                if rule_type in ['value', 'header']:
                    rules[rule_type][source_address] = target_field
        
        workbook.close()
        
        if not any(rules.values()):
            raise ValueError(f"Лист 'rules' пуст или не содержит корректных правил в {template_path}")
        
        return rules

    def _apply_rules_to_template(self, workbook, rules: Dict[str, Dict[str, str]], data_dict: Dict[str, any]):
        """Применяет правила заполнения к шаблону"""
        for rule_type, rule_items in rules.items():
            for cell_address, field_name in rule_items.items():
                value = data_dict.get(field_name, field_name if rule_type == 'header' else '')
                is_formula, clean_address, sheet_name = self._parse_cell_address(cell_address)
                self._fill_cell_or_range(workbook, sheet_name, clean_address, value)

    def create_employee_file(self, employee: Employee, output_path: str) -> bool:
        """Создает файл сотрудника на основе шаблона с rules"""
        template_path = Path(self.config.employee_template)
        if not template_path.exists():
            raise FileNotFoundError(f"Шаблон сотрудника не найден: {template_path}")
        
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(template_path, output_path)
        
        rules = self._load_filling_rules(str(template_path))
        
        employee_data = {
            'ФИО работника': employee.full_name,
            'Табельный номер': employee.tab_number,
            'Должность': getattr(employee, 'position', ''),
            'Подразделение 1': employee.department1,
            'Подразделение 2': employee.department2,
            'Подразделение 3': employee.department3,
            'Подразделение 4': employee.department4,
            'Локация': getattr(employee, 'location', ''),
            'Остатки отпуска': getattr(employee, 'vacation_remainder', ''),
            'Дата приема': getattr(employee, 'hire_date', ''),
            'Дата отсечки периода': getattr(employee, 'period_cutoff_date', ''),
            'Дополнительный отпуск НРД': getattr(employee, 'additional_vacation_nrd', ''),
            'Дополнительный отпуск Северный': getattr(employee, 'additional_vacation_north', '')
        }
        
        workbook = openpyxl.load_workbook(output_path)
        self._apply_rules_to_template(workbook, rules, employee_data)
        workbook.save(output_path)
        workbook.close()
        
        return True

    def read_vacation_info_from_file(self, file_path: str) -> Optional[VacationInfo]:
        """Читает информацию об отпусках из файла сотрудника"""
        try:
            workbook = openpyxl.load_workbook(file_path, data_only=True)
            worksheet = workbook.active
            
            employee = Employee()
            
            # Ищем первую заполненную строку для базовой информации
            for row in range(9, 24):
                tab_number = self._get_cell_value(worksheet, f"B{row}")
                full_name = self._get_cell_value(worksheet, f"C{row}")
                position = self._get_cell_value(worksheet, f"D{row}")
                
                if tab_number and full_name:
                    employee.tab_number = str(tab_number).strip()
                    employee.full_name = str(full_name).strip()
                    if position:
                        employee.position = str(position).strip()
                    break
            
            # Читаем подразделения из шапки файла
            employee.department1 = str(self._get_cell_value(worksheet, "C2") or "").strip()
            employee.department2 = str(self._get_cell_value(worksheet, "C3") or "").strip()
            employee.department3 = str(self._get_cell_value(worksheet, "C4") or "").strip()
            employee.department4 = str(self._get_cell_value(worksheet, "C5") or "").strip()
            
            # Читаем периоды отпусков
            periods = []
            for row in range(9, 24):
                start_date_value = self._get_cell_value(worksheet, f"E{row}")
                end_date_value = self._get_cell_value(worksheet, f"F{row}")
                days_value = self._get_cell_value(worksheet, f"G{row}")
                
                if not start_date_value or not end_date_value:
                    continue
                
                try:
                    start_date = self._parse_date(start_date_value)
                    end_date = self._parse_date(end_date_value)
                    
                    if not start_date or not end_date:
                        continue
                    
                    days = int(days_value) if days_value else (end_date - start_date).days + 1
                    periods.append(VacationPeriod(start_date=start_date, end_date=end_date, days=days))
                    
                except Exception as e:
                    self.logger.warning(f"Ошибка обработки периода в строке {row}: {e}")
                    continue
            
            # Читаем результаты валидации
            validation_errors = []
            validation_h2 = str(self._get_cell_value(worksheet, "H2") or "").strip()
            validation_i2 = str(self._get_cell_value(worksheet, "I2") or "").strip()
            validation_j2 = self._get_cell_value(worksheet, "J2") or 0
            
            if "ОШИБКА" in validation_h2:
                validation_errors.append(validation_h2)
            if "ОШИБКА" in validation_i2:
                validation_errors.append(validation_i2)
            
            try:
                total_days = int(validation_j2) if validation_j2 else 0
                if total_days < 28:
                    validation_errors.append(f"ОШИБКА: Недостаточно дней отпуска. Запланировано {total_days} дней, требуется минимум 28.")
            except (ValueError, TypeError):
                validation_errors.append("ОШИБКА: Не удалось определить общее количество дней отпуска.")
            
            vacation_info = VacationInfo(employee=employee, periods=periods)
            vacation_info.validation_errors = validation_errors
            vacation_info.status = VacationStatus.OK if not validation_errors else VacationStatus.ERROR
            
            workbook.close()
            return vacation_info
            
        except Exception as e:
            self.logger.error(f"Ошибка чтения файла {file_path}: {e}")
            return None

    def create_block_report(self, block_name: str, vacation_infos: List[VacationInfo], output_path: str) -> bool:
        """Создает отчет по блоку с использованием rules"""
        # Пробуем новый шаблон, fallback на старый
        template_path = Path(self.config.block_report_template.replace("block_report_template.xlsx", "block_report_template v3.xlsx"))
        if not template_path.exists():
            template_path = Path(self.config.block_report_template)
            
        if not template_path.exists():
            raise FileNotFoundError(f"Шаблон отчета не найден: {template_path}")
        
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(template_path, output_path)
        
        rules = self._load_filling_rules(str(template_path))
        workbook = openpyxl.load_workbook(output_path)
        
        self._fill_report_with_rules(workbook, block_name, vacation_infos, rules)
        
        workbook.save(output_path)
        workbook.close()
        
        self.logger.info(f"Создан отчет по блоку: {output_path}")
        return True

    def _fill_report_with_rules(self, workbook, block_name: str, vacation_infos: List[VacationInfo], rules: Dict[str, Dict[str, str]]):
        """Заполняет отчет используя rules"""
        current_time = datetime.now()
        total_employees = len(vacation_infos)
        employees_filled = sum(1 for vi in vacation_infos if vi.periods)
        employees_correct = sum(1 for vi in vacation_infos if vi.status == VacationStatus.OK)
        
        # Данные для заполнения
        report_data = {
            'block_name': block_name,
            'update_date': f"Дата обновления: {current_time.strftime('%d.%m.%Y %H:%M')}",
            'total_employees': f"Всего сотрудников: {total_employees}",
            'employees_filled': f"Сотрудников заполнивших форму: {employees_filled}",
            'employees_correct': f"Сотрудников корректно заполнивших форму: {employees_correct}",
        }
        
        # Применяем rules
        self._apply_rules_to_template(workbook, rules, report_data)
        
        # Заполняем таблицы данных
        self._fill_employee_tables(workbook, vacation_infos, rules)
        
        # Заполняем календарь на Report листе
        if 'Report' in workbook.sheetnames:
            self._fill_calendar_matrix(workbook['Report'], vacation_infos)

    def _fill_employee_tables(self, workbook, vacation_infos: List[VacationInfo], rules: Dict[str, Dict[str, str]]):
        """Заполняет таблицы сотрудников на Report и Print листах"""
        # Report лист - таблица сотрудников
        if 'Report' in workbook.sheetnames:
            self._fill_table_by_prefix(workbook['Report'], vacation_infos, rules, 'report_', self._get_report_row_data)
        
        # Print лист - нормализованная таблица периодов
        if 'Print' in workbook.sheetnames:
            normalized_data = self._normalize_vacation_data(vacation_infos)
            self._fill_table_by_prefix(workbook['Print'], normalized_data, rules, 'print_', self._get_print_row_data)
            self._apply_borders_to_table(workbook['Print'], len(normalized_data))

    def _fill_table_by_prefix(self, worksheet, data_list: List, rules: Dict[str, Dict[str, str]], prefix: str, row_data_func):
        """Универсальная функция заполнения таблицы по префиксу"""
        header_rules = rules.get('header', {})
        column_mapping = {}
        base_row = 9
        
        # Определяем mapping столбцов и базовую строку
        for cell_address, field_name in header_rules.items():
            if field_name.startswith(prefix):
                try:
                    is_formula, clean_address, sheet_name = self._parse_cell_address(cell_address)
                    if ':' not in clean_address and ';' not in clean_address:
                        col_match = re.search(r'([A-Z]+)', clean_address)
                        row_match = re.search(r'(\d+)', clean_address)
                        
                        if col_match:
                            column_mapping[field_name] = col_match.group(1)
                        
                        if field_name == f'{prefix}row_number' and row_match:
                            base_row = int(row_match.group(1)) + 1
                except:
                    continue
        
        # Заполняем данные
        for i, data_item in enumerate(data_list):
            row = base_row + i
            row_data = row_data_func(data_item, i)
            
            for field_name, value in row_data.items():
                full_field_name = f'{prefix}{field_name}'
                if full_field_name in column_mapping:
                    worksheet[f"{column_mapping[full_field_name]}{row}"] = value

    def _get_report_row_data(self, vacation_info: VacationInfo, index: int) -> Dict[str, any]:
        """Возвращает данные строки для Report листа"""
        emp = vacation_info.employee
        return {
            'row_number': index + 1,
            'employee_name': emp.full_name,
            'tab_number': emp.tab_number,
            'position': getattr(emp, 'position', ''),
            'department1': emp.department1,
            'department2': emp.department2,
            'department3': emp.department3,
            'department4': emp.department4,
            'status': "Ок" if vacation_info.status == VacationStatus.OK else "\n".join(getattr(vacation_info, 'validation_errors', []) or ["Ошибка"]),
            'total_days': vacation_info.total_days,
            'periods_count': vacation_info.periods_count
        }

    def _get_print_row_data(self, normalized_record: Dict, index: int) -> Dict[str, any]:
        """Возвращает данные строки для Print листа"""
        emp = normalized_record['employee']
        return {
            'row_number': index + 1,
            'tab_number': emp.tab_number,
            'employee_name': emp.full_name,
            'position': getattr(emp, 'position', ''),
            'start_date': normalized_record['start_date'].strftime('%d.%m.%Y') if normalized_record['start_date'] else '',
            'end_date': normalized_record['end_date'].strftime('%d.%m.%Y') if normalized_record['end_date'] else '',
            'duration': normalized_record['days'] if normalized_record['days'] > 0 else ''
        }

    def _normalize_vacation_data(self, vacation_infos: List[VacationInfo]) -> List[Dict]:
        """Нормализует данные отпусков - каждый период = отдельная строка"""
        normalized_data = []
        for vacation_info in vacation_infos:
            emp = vacation_info.employee
            if not vacation_info.periods:
                normalized_data.append({
                    'employee': emp, 'period_num': 0, 'start_date': None, 'end_date': None, 'days': 0
                })
            else:
                for period_idx, period in enumerate(vacation_info.periods, 1):
                    normalized_data.append({
                        'employee': emp, 'period_num': period_idx,
                        'start_date': period.start_date, 'end_date': period.end_date, 'days': period.days
                    })
        return normalized_data

    def _apply_borders_to_table(self, worksheet, data_count: int):
        """Применяет границы к таблице Print листа"""
        thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), 
                           top=Side(style='thin'), bottom=Side(style='thin'))
        
        for row in range(9, 9 + data_count):
            for col in range(1, 11):  # A-J
                worksheet.cell(row=row, column=col).border = thin_border

    def _fill_calendar_matrix(self, worksheet, vacation_infos: List[VacationInfo]):
        """Заполняет календарную матрицу"""
        start_col = 12
        col_offset = 0
        
        for month_idx, month_name in enumerate(self.MONTH_NAMES):
            month_col = start_col + col_offset
            worksheet.cell(row=7, column=month_col, value=month_name)
            
            days_in_month = self.DAYS_IN_MONTH_2026[month_idx]
            for day in range(1, days_in_month + 1):
                day_col = start_col + col_offset + day - 1
                worksheet.cell(row=8, column=day_col, value=day)
            
            col_offset += days_in_month
        
        for emp_idx, vacation_info in enumerate(vacation_infos):
            emp_row = emp_idx + 9
            for period in vacation_info.periods:
                current_date = period.start_date
                while current_date <= period.end_date:
                    if current_date.year == 2026:
                        day_col = self._get_calendar_column(current_date, start_col)
                        if day_col:
                            worksheet.cell(row=emp_row, column=day_col, value=1)
                    
                    from datetime import timedelta
                    current_date = current_date + timedelta(days=1)
                    if current_date > period.end_date:
                        break

    def _get_calendar_column(self, target_date: date, start_col: int) -> Optional[int]:
        """Вычисляет столбец для даты в календаре"""
        if target_date.year != 2026:
            return None
        
        col_offset = sum(self.DAYS_IN_MONTH_2026[:target_date.month - 1]) + target_date.day - 1
        return start_col + col_offset

    def read_block_report_data(self, report_path: str) -> Optional[Dict]:
        """Читает данные из отчета по блоку"""
        try:
            workbook = openpyxl.load_workbook(report_path, data_only=True)
            if 'Report' not in workbook.sheetnames:
                return None
            
            worksheet = workbook['Report']
            
            block_name = str(self._get_cell_value(worksheet, "A3") or "").strip()
            update_date_raw = str(self._get_cell_value(worksheet, "A4") or "").strip()
            total_employees_raw = str(self._get_cell_value(worksheet, "A5") or "").strip()
            completed_raw = str(self._get_cell_value(worksheet, "A6") or "").strip()
            
            update_date = update_date_raw.replace("Дата обновления:", "").strip() if "Дата обновления:" in update_date_raw else ""
            
            total_employees = 0
            if "Количество сотрудников:" in total_employees_raw:
                try:
                    total_employees = int(total_employees_raw.split(":")[1].strip())
                except (ValueError, IndexError):
                    pass
            
            completed_employees = 0
            percentage = 0
            if "Закончили планирование:" in completed_raw:
                try:
                    parts = completed_raw.split(":")[1].strip().split("(")
                    completed_employees = int(parts[0].strip())
                    if len(parts) > 1:
                        percentage = int(parts[1].replace("%)", "").strip())
                except (ValueError, IndexError):
                    pass
            
            workbook.close()
            
            return {
                'block_name': block_name,
                'total_employees': total_employees,
                'completed_employees': completed_employees,
                'remaining_employees': total_employees - completed_employees,
                'percentage': percentage,
                'update_date': update_date
            }
            
        except Exception as e:
            self.logger.error(f"Ошибка чтения отчета {report_path}: {e}")
            return None

    def create_general_report_from_blocks(self, block_data: List[Dict], output_path: str) -> bool:
        """Создает общий отчет"""
        template_path = Path(self.config.general_report_template)
        if not template_path.exists():
            raise FileNotFoundError(f"Шаблон общего отчета не найден: {template_path}")
        
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(template_path, output_path)
        
        workbook = openpyxl.load_workbook(output_path)
        worksheet = workbook.active
        
        # Заполняем данные
        for i, data in enumerate(block_data):
            row = 6 + i
            if i > 0:  # Вставляем строки для дополнительных блоков
                worksheet.insert_rows(row, 1)
            
            worksheet[f"A{row}"] = i + 1
            worksheet[f"B{row}"] = data['block_name']
            worksheet[f"C{row}"] = f"{data['percentage']}%"
            worksheet[f"D{row}"] = data['total_employees']
            worksheet[f"E{row}"] = data['completed_employees']
            worksheet[f"F{row}"] = data['remaining_employees']
            worksheet[f"G{row}"] = data['update_date']
        
        # Границы
        thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), 
                           top=Side(style='thin'), bottom=Side(style='thin'))
        for i in range(len(block_data)):
            row = 6 + i
            for col in range(1, 8):
                worksheet.cell(row=row, column=col).border = thin_border
        
        # Формулы итого
        if block_data:
            total_row = 6 + len(block_data) + 1
            data_end_row = 6 + len(block_data) - 1
            worksheet[f"C{total_row}"] = f'=ROUND(E{total_row}/D{total_row}*100,0)&"%"'
            worksheet[f"D{total_row}"] = f'=SUM(D6:D{data_end_row})'
            worksheet[f"E{total_row}"] = f'=SUM(E6:E{data_end_row})'
            worksheet[f"F{total_row}"] = f'=SUM(F6:F{data_end_row})'
        
        workbook.save(output_path)
        workbook.close()
        return True

    def _get_cell_value(self, worksheet, cell_address: str):
        """Безопасно получает значение ячейки"""
        try:
            return worksheet[cell_address].value
        except Exception:
            return None

    def _parse_date(self, date_value) -> Optional[date]:
        """Парсит дату из различных форматов"""
        if not date_value:
            return None
        
        if isinstance(date_value, date):
            return date_value
        if isinstance(date_value, datetime):
            return date_value.date()
        
        date_str = str(date_value).strip()
        if not date_str:
            return None
        
        formats = ["%d.%m.%Y", "%d.%m.%y", "%Y-%m-%d", "%d/%m/%Y", "%d/%m/%y"]
        
        for fmt in formats:
            try:
                return datetime.strptime(date_str, fmt).date()
            except ValueError:
                continue
        
        return None

    def generate_output_filename(self, employee: Employee) -> str:
        """Генерирует имя файла для сотрудника"""
        clean_fio = self._clean_filename(employee.full_name)
        clean_tab_num = self._clean_filename(employee.tab_number)
        return f"{clean_fio} ({clean_tab_num}).xlsx"

    def generate_block_report_filename(self, block_name: str) -> str:
        """Генерирует имя файла отчета по блоку"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        clean_block_name = self._clean_filename(block_name)
        return f"Отчет по блоку_{clean_block_name}_{timestamp}.xlsx"

    def _clean_filename(self, filename: str) -> str:
        """Очищает имя файла от недопустимых символов"""
        if not filename:
            return "unnamed"
        
        clean_name = re.sub(r'[\\/:*?"<>|]', '_', filename).strip()
        return clean_name[:100] if len(clean_name) > 100 else clean_name or "unnamed"



=============================================
FILE: D:\Users\chernousov-am\vp on pt\core\file_manager.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Модуль управления файлами и папками
"""

import logging
import time
import shutil
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Callable, Optional, Tuple

from models import Employee, VacationInfo
from config import Config
from core.excel_handler import ExcelHandler


class FileManager:
    """Класс для управления файлами и структурой папок"""
    
    def __init__(self, config: Config):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.excel_handler = ExcelHandler(config)
        
    def scan_existing_departments(self, target_directory: str) -> Dict[str, str]:
        """
        Сканирует существующие папки подразделений
        
        Args:
            target_directory: путь к целевой папке
            
        Returns:
            Dict[str, str]: словарь {название_подразделения: путь_к_папке}
        """
        try:
            target_path = Path(target_directory)
            if not target_path.exists():
                self.logger.warning(f"Целевая папка не существует: {target_directory}")
                return {}
            
            departments = {}
            
            # Сканируем все папки в целевой директории
            for item in target_path.iterdir():
                if item.is_dir():
                    # Исключаем системные папки
                    if not item.name.startswith('.') and not item.name.startswith('__'):
                        departments[item.name] = str(item)
            
            self.logger.info(f"Найдено подразделений: {len(departments)}")
            return departments
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования папки {target_directory}: {e}")
            return {}

    def group_employees_by_department(self, employees: List[Employee]) -> Dict[str, List[Employee]]:
        """
        Группирует сотрудников по подразделениям
        
        Args:
            employees: список сотрудников
            
        Returns:
            Dict[str, List[Employee]]: словарь {подразделение: [сотрудники]}
        """
        try:
            departments = {}
            
            for employee in employees:
                # Используем первое непустое подразделение
                dept_name = None
                for dept in [employee.department1, employee.department2, employee.department3, employee.department4]:
                    if dept and dept.strip():
                        dept_name = dept.strip()
                        break
                
                if not dept_name:
                    dept_name = "Без подразделения"
                
                if dept_name not in departments:
                    departments[dept_name] = []
                
                departments[dept_name].append(employee)
            
            self.logger.info(f"Сотрудники сгруппированы по {len(departments)} подразделениям")
            return departments
            
        except Exception as e:
            self.logger.error(f"Ошибка группировки сотрудников: {e}")
            return {}

    def create_output_directory(self, base_path: str) -> str:
        """
        Создает выходную папку с timestamp
        
        Args:
            base_path: базовый путь для создания папки
            
        Returns:
            str: путь к созданной папке
        """
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_dir = Path(base_path) / f"vacation_files_{timestamp}"
            output_dir.mkdir(parents=True, exist_ok=True)
            
            self.logger.info(f"Создана выходная папка: {output_dir}")
            return str(output_dir)
            
        except Exception as e:
            self.logger.error(f"Ошибка создания выходной папки: {e}")
            raise
    
    def create_or_use_department_structure(self, output_dir: str, employees: List[Employee]) -> Dict[str, str]:
        """
        Создает структуру папок по подразделениям или использует существующие
        ВАЖНО: НЕ ИЗМЕНЯЕТ СТРУКТУРУ ФАЙЛОВ, только создает недостающие папки
        
        Args:
            output_dir: выходная папка
            employees: список сотрудников
            
        Returns:
            Dict[str, str]: словарь {название_подразделения: путь_к_папке}
        """
        departments = {}
        
        try:
            # Собираем уникальные подразделения из файла
            dept_set = set()
            for emp in employees:
                if emp.department1:
                    dept_set.add(emp.department1)
            
            # Проверяем существующие папки и создаем только недостающие
            output_path = Path(output_dir)
            
            for dept in dept_set:
                clean_dept_name = self._clean_directory_name(dept)
                dept_path = output_path / clean_dept_name
                
                # Создаем папку только если ее нет
                if not dept_path.exists():
                    dept_path.mkdir(parents=True, exist_ok=True)
                    self.logger.info(f"Создана папка отдела: {clean_dept_name}")
                else:
                    self.logger.info(f"Используется существующая папка: {clean_dept_name}")
                
                departments[dept] = str(dept_path)
            
            self.logger.info(f"Подготовлено отделов: {len(departments)}")
            return departments
            
        except Exception as e:
            self.logger.error(f"Ошибка подготовки структуры подразделений: {e}")
            raise
    
    def create_department_structure(self, output_dir: str, employees: List[Employee]) -> Dict[str, str]:
        """
        Создает структуру папок по подразделениям
        
        Args:
            output_dir: выходная папка
            employees: список сотрудников
            
        Returns:
            Dict[str, str]: словарь {название_подразделения: путь_к_папке}
        """
        departments = {}
        
        try:
            # Собираем уникальные подразделения
            dept_set = set()
            for emp in employees:
                if emp.department1:
                    dept_set.add(emp.department1)
            
            # Создаем папки для каждого подразделения
            for dept in dept_set:
                clean_dept_name = self._clean_directory_name(dept)
                dept_path = Path(output_dir) / clean_dept_name
                dept_path.mkdir(parents=True, exist_ok=True)
                departments[dept] = str(dept_path)
            
            self.logger.info(f"Создано подразделений: {len(departments)}")
            return departments
            
        except Exception as e:
            self.logger.error(f"Ошибка создания структуры подразделений: {e}")
            raise
    
    def create_employee_files_with_skip(
        self, 
        employees: List[Employee], 
        departments: Dict[str, str],
        progress_callback: Optional[Callable[[int, int, str], None]] = None,
        department_progress_callback: Optional[Callable[[int, int, str], None]] = None
    ) -> Tuple[int, int]:
        """
        Создает файлы сотрудников с пропуском существующих
        
        Args:
            employees: список сотрудников
            departments: словарь папок подразделений
            progress_callback: функция обратного вызова для прогресса по файлам
            department_progress_callback: функция обратного вызова для прогресса по отделам
            
        Returns:
            Tuple[int, int]: количество успешно созданных файлов и пропущенных
        """
        total = len(employees)
        success_count = 0
        skipped_count = 0
        
        # Группируем сотрудников по отделам для прогресса
        employees_by_dept = {}
        for emp in employees:
            if emp.department1 not in employees_by_dept:
                employees_by_dept[emp.department1] = []
            employees_by_dept[emp.department1].append(emp)
        
        total_departments = len(employees_by_dept)
        processed_departments = 0
        processed_files_total = 0
        
        for dept_name, dept_employees in employees_by_dept.items():
            # Обновляем прогресс по отделам
            if department_progress_callback:
                department_progress_callback(processed_departments, total_departments, dept_name)
            
            dept_path = departments.get(dept_name)
            if not dept_path:
                self.logger.warning(f"Папка для подразделения {dept_name} не найдена")
                processed_departments += 1
                continue
            
            # Обрабатываем сотрудников в текущем отделе
            for i, employee in enumerate(dept_employees):
                try:
                    # Генерируем имя файла
                    filename = self.excel_handler.generate_output_filename(employee)
                    output_path = Path(dept_path) / filename
                    
                    # Проверяем существование файла
                    if output_path.exists():
                        skipped_count += 1
                        message = f"Пропущен (уже существует): {employee.full_name}"
                    else:
                        # Создаем файл сотрудника
                        success = self.excel_handler.create_employee_file(employee, str(output_path))
                        
                        if success:
                            success_count += 1
                            message = f"Создан: {employee.full_name}"
                        else:
                            message = f"Ошибка создания: {employee.full_name}"
                    
                    processed_files_total += 1
                    
                    # Обновляем прогресс по файлам
                    if progress_callback:
                        progress_callback(processed_files_total, total, message)
                    
                    # Небольшая задержка для демонстрации прогресса
                    time.sleep(0.05)
                    
                except Exception as e:
                    self.logger.error(f"Ошибка создания файла для {employee.full_name}: {e}")
                    processed_files_total += 1
                    if progress_callback:
                        progress_callback(processed_files_total, total, f"Ошибка: {employee.full_name}")
            
            processed_departments += 1
            
            # Финальное обновление прогресса по отделам
            if department_progress_callback:
                department_progress_callback(processed_departments, total_departments, dept_name)
        
        self.logger.info(f"Создано файлов сотрудников: {success_count} сотр., пропущено: {skipped_count} из {total} сотр.")
        return success_count, skipped_count
    
    def create_employee_files(
        self, 
        employees: List[Employee], 
        departments: Dict[str, str],
        progress_callback: Optional[Callable[[int, int, str], None]] = None,
        department_progress_callback: Optional[Callable[[int, int, str], None]] = None
    ) -> int:
        """
        Создает файлы сотрудников (старый метод без пропуска)
        
        Args:
            employees: список сотрудников
            departments: словарь папок подразделений
            progress_callback: функция обратного вызова для прогресса по файлам
            department_progress_callback: функция обратного вызова для прогресса по отделам
            
        Returns:
            int: количество успешно созданных файлов
        """
        total = len(employees)
        success_count = 0
        
        # Группируем сотрудников по отделам для прогресса
        employees_by_dept = {}
        for emp in employees:
            if emp.department1 not in employees_by_dept:
                employees_by_dept[emp.department1] = []
            employees_by_dept[emp.department1].append(emp)
        
        total_departments = len(employees_by_dept)
        processed_departments = 0
        processed_files_total = 0
        
        for dept_name, dept_employees in employees_by_dept.items():
            # Обновляем прогресс по отделам
            if department_progress_callback:
                department_progress_callback(processed_departments, total_departments, dept_name)
            
            dept_path = departments.get(dept_name)
            if not dept_path:
                self.logger.warning(f"Папка для подразделения {dept_name} не найдена")
                processed_departments += 1
                continue
            
            # Обрабатываем сотрудников в текущем отделе
            for i, employee in enumerate(dept_employees):
                try:
                    # Генерируем имя файла
                    filename = self.excel_handler.generate_output_filename(employee)
                    output_path = Path(dept_path) / filename
                    
                    # Проверяем существование файла
                    if output_path.exists():
                        message = f"Пропущен (уже существует): {employee.full_name}"
                    else:
                        # Создаем файл сотрудника
                        success = self.excel_handler.create_employee_file(employee, str(output_path))
                        
                        if success:
                            success_count += 1
                            message = f"Создан: {employee.full_name}"
                        else:
                            message = f"Ошибка создания: {employee.full_name}"
                    
                    processed_files_total += 1
                    
                    # Обновляем прогресс по файлам
                    if progress_callback:
                        progress_callback(processed_files_total, total, message)
                    
                    # Небольшая задержка для демонстрации прогресса
                    time.sleep(0.05)
                    
                except Exception as e:
                    self.logger.error(f"Ошибка создания файла для {employee.full_name}: {e}")
                    processed_files_total += 1
                    if progress_callback:
                        progress_callback(processed_files_total, total, f"Ошибка: {employee.full_name}")
            
            processed_departments += 1
            
            # Финальное обновление прогресса по отделам
            if department_progress_callback:
                department_progress_callback(processed_departments, total_departments, dept_name)
        
        self.logger.info(f"Создано файлов сотрудников: {success_count} из {total}")
        return success_count
    
    def scan_employee_files(self, base_dir: str) -> Dict[str, List[str]]:
        """
        Сканирует файлы сотрудников в папках подразделений
        
        Args:
            base_dir: базовая папка для сканирования
            
        Returns:
            Dict[str, List[str]]: словарь {название_блока: [список_путей_к_файлам]}
        """
        result = {}
        
        try:
            base_path = Path(base_dir)
            if not base_path.exists():
                self.logger.warning(f"Папка не существует: {base_dir}")
                return result
            
            # Получаем список папок подразделений
            for entry in base_path.iterdir():
                if not entry.is_dir():
                    continue
                
                dept_name = entry.name
                employee_files = self._scan_department_files(entry)
                
                if employee_files:
                    result[dept_name] = employee_files
            
            self.logger.info(f"Найдено блоков: {len(result)}")
            return result
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования папки: {e}")
            return result
    
    def read_vacation_info_from_files(
        self, 
        files: List[str],
        progress_callback: Optional[Callable[[int, int, str], None]] = None
    ) -> List[VacationInfo]:
        """
        Читает информацию об отпусках из файлов
        
        Args:
            files: список путей к файлам
            progress_callback: функция обратного вызова для прогресса
            
        Returns:
            List[VacationInfo]: список информации об отпусках
        """
        result = []
        total = len(files)
        
        for i, file_path in enumerate(files):
            try:
                vacation_info = self.excel_handler.read_vacation_info_from_file(file_path)
                
                if vacation_info:
                    result.append(vacation_info)
                    message = f"Обработан: {vacation_info.employee.full_name}"
                else:
                    message = f"Ошибка чтения: {Path(file_path).name}"
                
                if progress_callback:
                    progress_callback(i + 1, total, message)
                
            except Exception as e:
                self.logger.error(f"Ошибка чтения файла {file_path}: {e}")
                if progress_callback:
                    progress_callback(i + 1, total, f"Ошибка: {Path(file_path).name}")
        
        self.logger.info(f"Обработано файлов: {len(result)} из {total}")
        return result
    
    def _scan_department_files(self, dept_path: Path) -> List[str]:
        """
        Сканирует файлы сотрудников в папке подразделения
        
        Args:
            dept_path: путь к папке подразделения
            
        Returns:
            List[str]: список путей к файлам сотрудников
        """
        files = []
        
        try:
            for entry in dept_path.iterdir():
                if not entry.is_file():
                    continue
                
                filename = entry.name
                
                # Проверяем расширение и исключаем файлы отчетов
                if (entry.suffix.lower() == '.xlsx' and 
                    not self._is_report_file(filename)):
                    files.append(str(entry))
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования папки {dept_path}: {e}")
        
        return files
    
    def _is_report_file(self, filename: str) -> bool:
        """
        Проверяет, является ли файл отчетом
        
        Args:
            filename: имя файла
            
        Returns:
            bool: True если это файл отчета
        """
        report_indicators = [
            "!",
            "summary_",
            "GENERAL_",
            "report_",
            "отчет",
            "ОБЩИЙ",
            "общий",
            "Отчет по блоку"  # Добавляем индикатор для наших отчетов
        ]
        
        filename_lower = filename.lower()
        
        for indicator in report_indicators:
            if (filename.startswith(indicator) or 
                indicator.lower() in filename_lower):
                return True
        
        return False
    
    def _clean_directory_name(self, name: str) -> str:
        """
        Очищает имя папки от недопустимых символов
        
        Args:
            name: исходное имя
            
        Returns:
            str: очищенное имя
        """
        if not name:
            return "unnamed"
        
        # Заменяем недопустимые символы для имен папок
        invalid_chars = r'[<>:"/\\|?*]'
        import re
        clean_name = re.sub(invalid_chars, '_', name)
        
        # Убираем лишние пробелы и точки в конце
        clean_name = clean_name.strip('. ')
        
        # Ограничиваем длину
        if len(clean_name) > 100:
            clean_name = clean_name[:100]
        
        return clean_name or "unnamed"



=============================================
FILE: D:\Users\chernousov-am\vp on pt\core\processor.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Основной процессор для обработки файлов отпусков
"""

import logging
import time
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Callable, Optional, Tuple

from models import (
    Employee, VacationInfo, BlockReport, GeneralReport, 
    ProcessingProgress, OperationLog, ProcessingStatus, ValidationResult
)
from config import Config
from core.validator import Validator
from core.excel_handler import ExcelHandler
from core.file_manager import FileManager


class VacationProcessor:
    """Основной класс для обработки операций с отпусками"""
    
    def __init__(self, config: Config):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.validator = Validator(config)
        self.excel_handler = ExcelHandler(config)
        self.file_manager = FileManager(config)

    def create_employee_files_to_existing(
        self, 
        staff_file_path: str, 
        target_directory: str,
        progress_callback: Optional[Callable[[ProcessingProgress], None]] = None,
        department_progress_callback: Optional[Callable[[int, int, str], None]] = None,
        file_progress_callback: Optional[Callable[[int, int, str], None]] = None
    ) -> OperationLog:
        """
        Создает файлы сотрудников в существующей папке
        """
        operation_log = OperationLog("Создание файлов сотрудников в существующей структуре")
        operation_log.add_entry("INFO", "Начало создания файлов сотрудников")
        
        try:
            start_time = datetime.now()
            progress = ProcessingProgress(
                current_operation="Начало обработки",
                start_time=start_time
            )
            
            if progress_callback:
                progress_callback(progress)
            
            # 1. Валидация файла штатного расписания
            progress.current_operation = "Валидация файла штатного расписания"
            progress.current_file = Path(staff_file_path).name
            if progress_callback:
                progress_callback(progress)
            
            validation_result, employees = self.validator.validate_staff_file(staff_file_path)
            if not validation_result.is_valid:
                operation_log.add_entry("ERROR", f"Валидация не пройдена: {validation_result.errors}")
                operation_log.finish(ProcessingStatus.ERROR)
                return operation_log
            
            operation_log.add_entry("INFO", f"Валидация пройдена. Найдено сотрудников: {len(employees)}")
            
            # 2. Группировка сотрудников по отделам
            progress.current_operation = "Группировка сотрудников по отделам"
            if progress_callback:
                progress_callback(progress)
            
            employees_by_dept = self.file_manager.group_employees_by_department(employees)
            
            # 3. Создание структуры папок
            progress.current_operation = "Подготовка структуры папок"
            if progress_callback:
                progress_callback(progress)
            
            departments = self.file_manager.create_or_use_department_structure(target_directory, employees)
            
            # 4. Подготовка прогресса
            total_departments = len(employees_by_dept)
            total_employees = len(employees)
            
            progress.total_blocks = total_departments
            progress.total_files = total_employees
            progress.processed_blocks = 0
            progress.processed_files = 0
            
            if progress_callback:
                progress_callback(progress)
            
            # 5. Создание файлов по отделам
            success_count = 0
            skipped_count = 0
            error_count = 0
            
            for dept_idx, (dept_name, dept_employees) in enumerate(employees_by_dept.items()):
                progress.current_operation = f"Обработка отдела: {dept_name}"
                progress.current_block = dept_name
                progress.processed_blocks = dept_idx
                
                if department_progress_callback:
                    department_progress_callback(dept_idx, total_departments, dept_name)
                
                if progress_callback:
                    progress_callback(progress)
                
                dept_path = departments.get(dept_name)
                if not dept_path:
                    operation_log.add_entry("ERROR", f"Папка для отдела {dept_name} не найдена")
                    continue
                
                # Обрабатываем сотрудников в текущем отделе
                for emp_idx, employee in enumerate(dept_employees):
                    try:
                        # Генерируем имя файла
                        filename = self.excel_handler.generate_output_filename(employee)
                        output_path = Path(dept_path) / filename
                        
                        # Проверяем существование файла
                        if output_path.exists():
                            skipped_count += 1
                            message = f"Пропущен: {employee.full_name}"
                        else:
                            # Создаем файл сотрудника - ВАЖНО: обрабатываем исключения
                            try:
                                create_success = self.excel_handler.create_employee_file(employee, str(output_path))
                                
                                if create_success:
                                    success_count += 1
                                    message = f"Создан: {employee.full_name}"
                                else:
                                    error_count += 1
                                    message = f"Ошибка: {employee.full_name}"
                                    operation_log.add_entry("ERROR", f"Не удалось создать файл для {employee.full_name}")
                            
                            except Exception as e:
                                error_count += 1
                                message = f"КРИТИЧЕСКАЯ ОШИБКА: {employee.full_name}"
                                operation_log.add_entry("ERROR", f"Критическая ошибка создания файла {employee.full_name}: {str(e)}")
                                
                                # Если есть ошибки в шаблоне - прерываем весь процесс
                                if "rules" in str(e).lower() or "шаблон" in str(e).lower() or "правил" in str(e).lower():
                                    operation_log.add_entry("ERROR", f"КРИТИЧЕСКАЯ ОШИБКА ШАБЛОНА: {str(e)}")
                                    operation_log.finish(ProcessingStatus.ERROR)
                                    return operation_log
                        
                        progress.processed_files += 1
                        
                        # Обновляем прогресс по файлам в отделе
                        if file_progress_callback:
                            file_progress_callback(emp_idx + 1, len(dept_employees), message)
                        
                        # Обновляем общий прогресс
                        if progress_callback:
                            progress_callback(progress)
                        
                        # Небольшая задержка
                        time.sleep(0.05)
                        
                    except Exception as e:
                        error_count += 1
                        self.logger.error(f"Ошибка создания файла для {employee.full_name}: {e}")
                        progress.processed_files += 1
                        if file_progress_callback:
                            file_progress_callback(emp_idx + 1, len(dept_employees), f"Ошибка: {employee.full_name}")
                
                # Логируем результат по отделу
                operation_log.add_entry("INFO", f"Отдел {dept_name}: создано {success_count - (dept_idx * len(dept_employees) if dept_idx > 0 else 0)}, пропущено файлов")
                
                # Завершаем обработку отдела
                progress.processed_blocks = dept_idx + 1
                
                if department_progress_callback:
                    department_progress_callback(dept_idx + 1, total_departments, dept_name)
            
            # 6. Завершение
            end_time = datetime.now()
            duration = end_time - start_time
            
            progress.current_operation = "Создание файлов завершено"
            progress.end_time = end_time
            if progress_callback:
                progress_callback(progress)
            
            # Проверяем результат
            if error_count > 0:
                operation_log.add_entry("ERROR", f"Обработка завершена с ошибками: успешно {success_count}, ошибок {error_count}, пропущено {skipped_count}")
                operation_log.finish(ProcessingStatus.ERROR)
            else:
                operation_log.add_entry("INFO", f"Создано файлов сотрудников: {success_count}, пропущено: {skipped_count} из {total_employees}")
                operation_log.add_entry("INFO", f"Время выполнения: {duration.total_seconds():.1f} сек")
                operation_log.finish(ProcessingStatus.SUCCESS)
            
            return operation_log
            
        except Exception as e:
            error_msg = f"Критическая ошибка: {e}"
            operation_log.add_entry("ERROR", error_msg)
            self.logger.error(error_msg, exc_info=True)
            operation_log.finish(ProcessingStatus.ERROR)
            
            return operation_log

    def scan_target_directory(self, target_directory: str) -> Dict[str, int]:
        """
        Сканирует целевую папку и возвращает информацию о подразделениях
        
        Args:
            target_directory: путь к папке для сканирования
            
        Returns:
            Dict[str, int]: {название_подразделения: количество_файлов}
        """
        try:
            departments = self.file_manager.scan_existing_departments(target_directory)
            
            # Подсчитываем файлы в каждом подразделении
            departments_info = {}
            for dept_name, dept_path in departments.items():
                files = self.file_manager._scan_department_files(Path(dept_path))
                departments_info[dept_name] = len(files)
            
            return departments_info
            
        except Exception as e:
            self.logger.error(f"Ошибка сканирования папки {target_directory}: {e}")
            return {}

    def update_block_reports(
        self,
        selected_departments: List[Dict],
        progress_callback: Optional[Callable[[ProcessingProgress], None]] = None
    ) -> OperationLog:
        """
        Обновляет отчеты по выбранным подразделениям
        
        Args:
            selected_departments: список выбранных подразделений в формате [{'name': str, 'path': str, 'files_count': int}]
            progress_callback: функция для обновления прогресса
            
        Returns:
            OperationLog: лог операции
        """
        operation_log = OperationLog("Обновление отчетов по подразделениям")
        operation_log.add_entry("INFO", "Начало обновления отчетов по блокам")
        
        try:
            start_time = datetime.now()
            total_files = sum(dept['files_count'] for dept in selected_departments)
            progress = ProcessingProgress(
                current_operation="Подготовка к созданию отчетов",
                start_time=start_time,
                total_blocks=len(selected_departments),
                total_files=total_files
            )
            
            if progress_callback:
                progress_callback(progress)
            
            success_count = 0
            error_count = 0
            files_processed_total = 0
            
            for i, dept_info in enumerate(selected_departments):
                dept_name = dept_info['name']
                dept_path = Path(dept_info['path'])
                files_in_dept = dept_info['files_count']
                
                progress.current_operation = f"Создание отчета: {dept_name}"
                progress.current_block = dept_name
                progress.processed_blocks = i
                if progress_callback:
                    progress_callback(progress)
                
                try:
                    if not dept_path.exists():
                        error_msg = f"Папка подразделения не найдена: {dept_name}"
                        operation_log.add_entry("ERROR", error_msg)
                        error_count += 1
                        continue
                    
                    # Читаем файлы сотрудников
                    employee_files = self.file_manager._scan_department_files(dept_path)
                    vacation_infos = []
                    
                    files_processed_in_dept = 0
                    for file_path in employee_files:
                        vacation_info = self.excel_handler.read_vacation_info_from_file(file_path)
                        if vacation_info:
                            vacation_infos.append(vacation_info)
                        
                        files_processed_in_dept += 1
                        files_processed_total += 1
                        progress.processed_files = files_processed_total
                        
                        # ИСПРАВЛЕНИЕ: Обновляем прогресс для каждого файла
                        if progress_callback:
                            progress_callback(progress)
                        
                        time.sleep(0.1)  # Небольшая задержка для демонстрации прогресса
                    
                    # Создаем отчет
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    report_filename = f"Отчет по блоку_{dept_name}_{timestamp}.xlsx"
                    report_path = dept_path / report_filename
                    
                    success = self.excel_handler.create_block_report(
                        dept_name, vacation_infos, str(report_path)
                    )
                    
                    if success:
                        success_count += 1
                        operation_log.add_entry("INFO", f"Создан отчет: {dept_name}")
                    else:
                        error_count += 1
                        operation_log.add_entry("ERROR", f"Ошибка создания отчета: {dept_name}")
                
                except Exception as e:
                    error_count += 1
                    error_msg = f"Ошибка обработки {dept_name}: {e}"
                    operation_log.add_entry("ERROR", error_msg)
                    self.logger.error(error_msg)
                
                # Обновляем прогресс по блокам
                progress.processed_blocks = i + 1
                if progress_callback:
                    progress_callback(progress)
            
            # Завершение
            end_time = datetime.now()
            duration = end_time - start_time
            
            progress.current_operation = "Отчеты созданы"
            progress.end_time = end_time
            if progress_callback:
                progress_callback(progress)
            
            operation_log.add_entry("INFO", f"Создание отчетов завершено за {duration.total_seconds():.1f} сек")
            operation_log.add_entry("INFO", f"Успешно: {success_count}, Ошибок: {error_count}")
            operation_log.finish(ProcessingStatus.SUCCESS)
            
            return operation_log
            
        except Exception as e:
            error_msg = f"Критическая ошибка: {e}"
            operation_log.add_entry("ERROR", error_msg)
            self.logger.error(error_msg, exc_info=True)
            operation_log.finish(ProcessingStatus.ERROR)
            
            return operation_log

    def create_general_report(
        self,
        selected_departments: List[Dict],
        base_directory: str,
        progress_callback: Optional[Callable[[ProcessingProgress], None]] = None
    ) -> OperationLog:
        """
        Создает общий отчет по выбранным подразделениям
        
        Args:
            selected_departments: список выбранных подразделений в формате [{'name': str, 'path': str, 'files_count': int}]
            base_directory: базовая папка для сохранения общего отчета
            progress_callback: функция для обновления прогресса
            
        Returns:
            OperationLog: лог операции
        """
        operation_log = OperationLog("Создание общего отчета")
        operation_log.add_entry("INFO", "Начало создания общего отчета")
        
        try:
            start_time = datetime.now()
            progress = ProcessingProgress(
                current_operation="Подготовка к созданию общего отчета",
                start_time=start_time,
                total_blocks=len(selected_departments),
                total_files=len(selected_departments)  # Каждый отдел = один файл для анализа
            )
            
            if progress_callback:
                progress_callback(progress)
            
            # Проверяем наличие отчетов по блокам и собираем данные
            block_data = []
            missing_reports = []
            
            for i, dept_info in enumerate(selected_departments):
                dept_name = dept_info['name']
                dept_path = Path(dept_info['path'])
                
                progress.current_operation = f"Проверка отчета: {dept_name}"
                progress.current_block = dept_name
                progress.processed_blocks = i
                progress.processed_files = i
                if progress_callback:
                    progress_callback(progress)
                
                # Ищем последний отчет по блоку
                block_report_path = self._find_latest_block_report(str(dept_path), dept_name)
                
                if block_report_path:
                    # Читаем данные из отчета
                    block_info = self.excel_handler.read_block_report_data(block_report_path)
                    if block_info:
                        block_data.append(block_info)
                        operation_log.add_entry("INFO", f"Найден отчет для {dept_name}")
                    else:
                        missing_reports.append(dept_name)
                        operation_log.add_entry("ERROR", f"Ошибка чтения отчета для {dept_name}")
                else:
                    missing_reports.append(dept_name)
                    operation_log.add_entry("ERROR", f"Отчет по блоку не найден для {dept_name}")
                    self.logger.error(f"Отчет по блоку не найден для подразделения: {dept_name}")
                
                # ИСПРАВЛЕНИЕ: Эмуляция работы с блоком (~2 секунды)
                time.sleep(2.0)
            
            # Если есть отсутствующие отчеты - прерываем выполнение
            if missing_reports:
                missing_deps_str = ", ".join(missing_reports)
                error_msg = f"Не найдены отчеты по блокам для подразделений: {missing_deps_str}"
                operation_log.add_entry("ERROR", error_msg)
                operation_log.finish(ProcessingStatus.ERROR)
                return operation_log
            
            # Создаем общий отчет
            progress.current_operation = "Создание общего отчета"
            progress.processed_files = len(selected_departments)
            progress.processed_blocks = len(selected_departments)
            if progress_callback:
                progress_callback(progress)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            report_filename = f"ОБЩИЙ_ОТЧЕТ_{timestamp}.xlsx"
            report_path = Path(base_directory) / report_filename
            
            success = self.excel_handler.create_general_report_from_blocks(
                block_data, str(report_path)
            )
            
            if success:
                end_time = datetime.now()
                duration = end_time - start_time
                
                progress.current_operation = "Общий отчет создан"
                progress.end_time = end_time
                if progress_callback:
                    progress_callback(progress)
                
                operation_log.add_entry("INFO", f"Общий отчет создан: {report_path}")
                operation_log.add_entry("INFO", f"Время выполнения: {duration.total_seconds():.1f} сек")
                operation_log.finish(ProcessingStatus.SUCCESS)
                
                self.logger.info(f"Общий отчет создан: {report_path}")
                
            else:
                error_msg = "Ошибка создания общего отчета"
                operation_log.add_entry("ERROR", error_msg)
                operation_log.finish(ProcessingStatus.ERROR)
            
            return operation_log
            
        except Exception as e:
            error_msg = f"Критическая ошибка: {e}"
            operation_log.add_entry("ERROR", error_msg)
            self.logger.error(error_msg, exc_info=True)
            operation_log.finish(ProcessingStatus.ERROR)
            
            return operation_log

    def _find_latest_block_report(self, dept_path: str, dept_name: str) -> Optional[str]:
        """
        Находит последний отчет по блоку для подразделения
        
        Args:
            dept_path: путь к папке подразделения
            dept_name: название подразделения
            
        Returns:
            Optional[str]: путь к файлу отчета или None
        """
        try:
            dept_path_obj = Path(dept_path)
            
            if not dept_path_obj.exists():
                self.logger.error(f"Папка подразделения не существует: {dept_path_obj}")
                return None
            
            # Ищем файлы отчетов
            report_files = []
            for file_path in dept_path_obj.iterdir():
                if file_path.is_file() and file_path.suffix.lower() == '.xlsx':
                    filename = file_path.name
                    if (filename.startswith("Отчет по блоку") or 
                        filename.startswith("отчет по блоку") or
                        "отчет" in filename.lower()):
                        report_files.append(file_path)
            
            if not report_files:
                self.logger.warning(f"Отчеты по блоку не найдены в {dept_path_obj}")
                return None
            
            # Возвращаем самый новый файл
            latest_file = max(report_files, key=lambda f: f.stat().st_mtime)
            return str(latest_file)
            
        except Exception as e:
            self.logger.error(f"Ошибка поиска отчета для {dept_name}: {e}")
            return None



=============================================
FILE: D:\Users\chernousov-am\vp on pt\core\validator.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Модуль валидации данных
"""

import logging
from pathlib import Path
from typing import List, Tuple, Optional
import re

import openpyxl
from openpyxl import Workbook

from models import Employee, ValidationResult
from config import Config


class Validator:
    """Класс для валидации файлов и данных"""
    
    def __init__(self, config: Config):
        self.config = config
        self.logger = logging.getLogger(__name__)
    
    def validate_staff_file(self, file_path: str) -> Tuple[ValidationResult, List[Employee]]:
        """
        Валидирует файл штатного расписания
        
        Returns:
            Tuple[ValidationResult, List[Employee]]: результат валидации и список сотрудников
        """
        result = ValidationResult()
        employees = []
        
        try:
            # Проверка существования файла
            file_path_obj = Path(file_path)
            if not file_path_obj.exists():
                result.add_error(f"Файл не существует: {file_path}")
                return result, employees
            
            # Проверка размера файла (максимум 50 МБ)
            file_size = file_path_obj.stat().st_size
            if file_size > 50 * 1024 * 1024:
                result.add_error("Размер файла превышает 50 МБ")
                return result, employees
            
            # Открытие Excel файла
            try:
                workbook = openpyxl.load_workbook(file_path, data_only=True)
            except Exception as e:
                result.add_error(f"Ошибка открытия Excel файла: {e}")
                return result, employees
            
            # Получение первого листа
            if not workbook.worksheets:
                result.add_error("В файле нет листов")
                return result, employees
            
            worksheet = workbook.active
            
            # Проверка заголовков
            header_row = self.config.header_row
            headers = self._get_row_values(worksheet, header_row)
            
            if not headers:
                result.add_error(f"Не удалось прочитать строку заголовков {header_row}")
                return result, employees
            
            # Проверка обязательных заголовков
            required_headers = ["ФИО работника", "Табельный номер", "Подразделение 1"]
            header_map = {header.strip(): idx for idx, header in enumerate(headers) if header}
            
            for required in required_headers:
                if required not in header_map:
                    result.add_error(f"Отсутствует обязательный заголовок: {required}")
            
            if not result.is_valid:
                return result, employees
            
            # Чтение данных сотрудников
            employees = self._read_employees(worksheet, header_row, header_map)
            
            # Валидация данных сотрудников
            self._validate_employees(employees, result)
            
            result.employee_count = len(employees)
            result.unique_tab_numbers = self._count_unique_tab_numbers(employees)
            result.processing_time = len(employees) * self.config.get("processing_time_per_file", 0.3)
            
            self.logger.info(f"Валидация завершена. Найдено сотрудников: {len(employees)}")
            
        except Exception as e:
            result.add_error(f"Неожиданная ошибка при валидации: {e}")
            self.logger.error(f"Ошибка валидации файла: {e}", exc_info=True)
        
        return result, employees
    
    def validate_templates(self) -> ValidationResult:
        """Проверяет наличие всех необходимых шаблонов"""
        result = ValidationResult()
        
        templates = {
            "Шаблон сотрудника": self.config.employee_template,
            "Шаблон отчета по блоку": self.config.block_report_template,
            "Шаблон общего отчета": self.config.general_report_template
        }
        
        for name, path in templates.items():
            if not Path(path).exists():
                result.add_error(f"Отсутствует {name}: {path}")
        
        return result
    
    def validate_output_directory(self, dir_path: str) -> ValidationResult:
        """Проверяет возможность записи в выходную папку"""
        result = ValidationResult()
        
        try:
            # Создаем папку если она не существует
            output_path = Path(dir_path)
            output_path.mkdir(parents=True, exist_ok=True)
            
            # Проверяем права на запись
            test_file = output_path / "test_write_permissions.tmp"
            try:
                test_file.touch()
                test_file.unlink()
            except Exception as e:
                result.add_error(f"Нет прав на запись в папку: {e}")
                
        except Exception as e:
            result.add_error(f"Невозможно создать выходную папку: {e}")
        
        return result
    
    def _get_row_values(self, worksheet, row_num: int) -> List[str]:
        """Получает значения строки"""
        values = []
        for cell in worksheet[row_num]:
            value = cell.value
            if value is None:
                values.append("")
            else:
                values.append(str(value).strip())
        return values
    
    def _read_employees(self, worksheet, header_row: int, header_map: dict) -> List[Employee]:
        """Читает данных сотрудников из листа"""
        employees = []
        
        # Начинаем с строки после заголовков
        for row_num in range(header_row + 1, worksheet.max_row + 1):
            row_values = self._get_row_values(worksheet, row_num)
            
            # Пропускаем пустые строки
            if not any(row_values):
                continue
            
            employee = Employee()
            
            # Заполняем данные сотрудника
            for field_name, column_idx in header_map.items():
                if column_idx < len(row_values):
                    value = row_values[column_idx].strip()
                    
                    if field_name == "ФИО работника":
                        employee.full_name = value
                    elif field_name == "Табельный номер":
                        employee.tab_number = value
                    elif field_name == "Должность":
                        employee.position = value
                    elif field_name == "Подразделение 1":
                        employee.department1 = value
                    elif field_name == "Подразделение 2":
                        employee.department2 = value
                    elif field_name == "Подразделение 3":
                        employee.department3 = value
                    elif field_name == "Подразделение 4":
                        employee.department4 = value
                    # Новые поля
                    elif field_name == "Локация":
                        employee.location = value
                    elif field_name == "Остатки отпуска":
                        employee.vacation_remainder = value
                    elif field_name == "Дата приема":
                        employee.hire_date = value
                    elif field_name == "Дата отсечки периода":
                        employee.period_cutoff_date = value
                    elif field_name == "Дополнительный отпуск НРД":
                        employee.additional_vacation_nrd = value
                    elif field_name == "Дополнительный отпуск Северный":
                        employee.additional_vacation_north = value
            
            # Добавляем только если есть обязательные поля
            if employee.full_name and employee.tab_number and employee.department1:
                employees.append(employee)
        
        return employees
    
    def _validate_employees(self, employees: List[Employee], result: ValidationResult):
        """Валидирует данные сотрудников"""
        tab_numbers = {}
        
        for i, emp in enumerate(employees, 1):
            # Проверка длины строк
            if len(emp.full_name) > 255:
                result.add_warning(f"Строка {i}: ФИО слишком длинное (>255 символов)")
            
            if len(emp.department1) > 255:
                result.add_warning(f"Строка {i}: Название подразделения слишком длинное")
            
            # Проверка табельного номера
            if not emp.tab_number:
                result.add_error(f"Строка {i}: Пустой табельный номер")
                continue
            
            # Проверка формата табельного номера
            if not re.match(r'^\d+$', emp.tab_number):
                result.add_warning(f"Строка {i}: Табельный номер не является числом: {emp.tab_number}")
            
            # Проверка уникальности табельного номера
            if emp.tab_number in tab_numbers:
                tab_numbers[emp.tab_number] += 1
                result.add_warning(f"Дублирующийся табельный номер: {emp.tab_number}")
            else:
                tab_numbers[emp.tab_number] = 1
        
        # Проверка количества сотрудников
        unique_count = len(tab_numbers)
        min_employees = self.config.min_employees
        max_employees = self.config.max_employees
        
        if unique_count < min_employees:
            result.add_error(f"Слишком мало сотрудников: {unique_count} (минимум {min_employees})")
        
        if unique_count > max_employees:
            result.add_error(f"Слишком много сотрудников: {unique_count} (максимум {max_employees})")
    
    def _count_unique_tab_numbers(self, employees: List[Employee]) -> int:
        """Подсчитывает количество уникальных табельных номеров"""
        unique_tabs = set()
        for emp in employees:
            if emp.tab_number:
                unique_tabs.add(emp.tab_number)
        return len(unique_tabs)
    



=============================================
FILE: D:\Users\chernousov-am\vp on pt\gui\create_files_window.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Окно создания файлов сотрудников
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import threading
import logging
from pathlib import Path
from typing import Optional, Dict
import re
from datetime import datetime


from config import Config
from core.processor import VacationProcessor
from models import ProcessingProgress, ProcessingStatus


class CreateFilesWindow:
    """Окно для создания файлов отпусков сотрудников"""
    

    def __init__(self, parent: tk.Tk, config: Config, main_window):
        """Конструктор окна создания файлов"""
        self.parent = parent
        self.config = config
        self.main_window = main_window
        self.logger = logging.getLogger(__name__)
        self.processor = VacationProcessor(config)
        
        # Состояние
        self.staff_file_path = ""
        self.output_dir_path = ""
        self.is_processing = False
        self.validation_result = None
        self.existing_files_info = {}
        self.new_employees_count = 0
        self.skip_employees_count = 0
        
        # НОВЫЕ ПЕРЕМЕННЫЕ для отслеживания повторных выборов
        self.file_reselected = False
        self.dir_reselected = False
        
        # Создаем окно
        self.window = None
        self.setup_ui()

    def setup_ui(self):
        """Настройка пользовательского интерфейса"""
        self.window = tk.Toplevel(self.parent)
        self.window.title("Создание файлов отпусков")
        self.window.geometry("750x600")
        self.window.resizable(True, True)
        
        # Обработчик закрытия
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        # Основной фрейм
        main_frame = ttk.Frame(self.window, padding="15")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Настройка сетки
        self.window.columnconfigure(0, weight=1)
        self.window.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Выбор файлов
        self.setup_file_selection(main_frame)
        
        # Информация/прогресс (занимает одно место)
        self.setup_info_progress_area(main_frame)
        
        # Кнопки управления (внизу по центру)
        self.setup_control_buttons(main_frame)
    
    def setup_file_selection(self, parent):
        """Настройка области выбора файлов"""
        files_frame = ttk.LabelFrame(parent, text="Выбор файлов", padding="10")
        files_frame.grid(row=0, column=0, columnspan=3, pady=(0, 15), sticky=(tk.W, tk.E))
        files_frame.columnconfigure(1, weight=1)
        
        # Файл с сотрудниками
        ttk.Label(files_frame, text="Файл с сотрудниками:").grid(
            row=0, column=0, sticky=tk.W, pady=5
        )
        
        self.staff_file_var = tk.StringVar()
        self.staff_file_entry = ttk.Entry(
            files_frame, 
            textvariable=self.staff_file_var,
            state="readonly"
        )
        self.staff_file_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(10, 5), pady=5)
        
        ttk.Button(
            files_frame,
            text="Выбрать",
            command=self.select_staff_file
        ).grid(row=0, column=2, pady=5)
        
        # Целевая папка
        ttk.Label(files_frame, text="Целевая папка:").grid(
            row=1, column=0, sticky=tk.W, pady=5
        )
        
        self.output_dir_var = tk.StringVar()
        self.output_dir_entry = ttk.Entry(
            files_frame,
            textvariable=self.output_dir_var,
            state="readonly"
        )
        self.output_dir_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(10, 5), pady=5)
        
        self.output_dir_btn = ttk.Button(
            files_frame,
            text="Выбрать",
            command=self.select_output_dir,
            state=tk.DISABLED
        )
        self.output_dir_btn.grid(row=1, column=2, pady=5)
    

    def setup_info_progress_area(self, parent):
        """Настройка области информации/прогресса"""
        # Информация (показывается по умолчанию)
        self.info_frame = ttk.LabelFrame(parent, text="Информация", padding="10")
        self.info_frame.grid(row=1, column=0, columnspan=3, pady=(0, 15), sticky=(tk.W, tk.E, tk.N, tk.S))
        self.info_frame.columnconfigure(0, weight=1)
        self.info_frame.rowconfigure(0, weight=1)
        
        # Текстовая область с прокруткой и возможностью копирования
        self.info_text = tk.Text(
            self.info_frame,
            height=12,
            wrap=tk.WORD,
            font=("TkDefaultFont", 9),
            state=tk.NORMAL,
            cursor="arrow"
        )
        
        # Делаем текст доступным для выделения и копирования
        def on_key(event):
            # Разрешаем только копирование
            if event.state & 0x4:  # Ctrl нажат
                if event.keysym.lower() in ['c', 'a']:
                    return  # Разрешаем Ctrl+C и Ctrl+A
            return "break"  # Блокируем все остальные клавиши
        
        self.info_text.bind('<Key>', on_key)
        self.info_text.bind('<Control-a>', lambda e: self.info_text.tag_add("sel", "1.0", "end"))
        
        # Контекстное меню для копирования
        def show_context_menu(event):
            try:
                context_menu = tk.Menu(self.info_text, tearoff=0)
                context_menu.add_command(label="Выделить всё", command=lambda: self.info_text.tag_add("sel", "1.0", "end"))
                context_menu.add_command(label="Копировать", command=lambda: self.copy_selected_text())
                context_menu.tk_popup(event.x_root, event.y_root)
            except:
                pass
        
        self.info_text.bind('<Button-3>', show_context_menu)
        
        info_scrollbar = ttk.Scrollbar(self.info_frame, orient=tk.VERTICAL, command=self.info_text.yview)
        self.info_text.configure(yscrollcommand=info_scrollbar.set)
        
        self.info_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        info_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # Инициализация
        self.add_info("Выберите файл с сотрудниками для начала работы")
        
        # Прогресс обработки (скрыт по умолчанию)
        self.progress_frame = ttk.LabelFrame(parent, text="Прогресс обработки", padding="10")
        self.progress_frame.columnconfigure(0, weight=1)
        
        # Общий прогресс и время
        self.overall_progress_label = ttk.Label(self.progress_frame, text="Готов к началу", font=("TkDefaultFont", 10, "bold"))
        self.overall_progress_label.grid(row=0, column=0, sticky=tk.W, pady=2)
        
        self.time_label = ttk.Label(self.progress_frame, text="", font=("TkDefaultFont", 9))
        self.time_label.grid(row=1, column=0, sticky=tk.W, pady=2)
        
        # Прогресс по отделам (основной)
        self.departments_label = ttk.Label(self.progress_frame, text="Отделы:", font=("TkDefaultFont", 9, "bold"))
        self.departments_label.grid(row=2, column=0, sticky=tk.W, pady=(10, 2))
        
        self.departments_progress_bar = ttk.Progressbar(
            self.progress_frame,
            mode='determinate',
            length=400
        )
        self.departments_progress_bar.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=2)
        
        self.departments_detail_label = ttk.Label(self.progress_frame, text="", font=("TkDefaultFont", 8))
        self.departments_detail_label.grid(row=4, column=0, sticky=tk.W, pady=2)
        
        # Прогресс по сотрудникам в текущем отделе (вторичный)
        self.employees_label = ttk.Label(self.progress_frame, text="Файлы в текущем отделе:", font=("TkDefaultFont", 9))
        self.employees_label.grid(row=5, column=0, sticky=tk.W, pady=(10, 2))
        
        self.employees_progress_bar = ttk.Progressbar(
            self.progress_frame,
            mode='determinate',
            length=400
        )
        self.employees_progress_bar.grid(row=6, column=0, sticky=(tk.W, tk.E), pady=2)
        
        self.employees_detail_label = ttk.Label(self.progress_frame, text="", font=("TkDefaultFont", 8))
        self.employees_detail_label.grid(row=7, column=0, sticky=tk.W, pady=2)

    
    def setup_control_buttons(self, parent):
        """Настройка кнопок управления"""
        buttons_frame = ttk.Frame(parent)
        buttons_frame.grid(row=2, column=0, columnspan=3, pady=(10, 15))
        
        # Центрирование кнопок
        buttons_frame.columnconfigure(0, weight=1)
        buttons_frame.columnconfigure(2, weight=1)
        
        # Кнопка создания файлов
        self.create_btn = ttk.Button(
            buttons_frame,
            text="Создать файлы",
            command=self.create_files,
            state=tk.DISABLED
        )
        self.create_btn.grid(row=0, column=1)
    
    def show(self):
        """Показывает окно"""
        if self.window:
            self.window.deiconify()
            self.window.lift()
            self.window.focus()

    def select_staff_file(self):
        """Выбор файла с сотрудниками"""
        file_path = filedialog.askopenfilename(
            title="Выберите файл с сотрудниками",
            filetypes=[
                ("Excel файлы", "*.xlsx *.xls"),
                ("Все файлы", "*.*")
            ]
        )
        
        if file_path:
            self.staff_file_path = file_path
            self.staff_file_var.set(file_path)
            
            # Полный сброс состояния при смене файла
            self._reset_state()
            
            self.add_info(f"Выбран файл: {Path(file_path).name}")
            
            # Активируем кнопку выбора папки
            self.output_dir_btn.config(state=tk.NORMAL)
            
            # ВАЖНО: сбрасываем кнопку создания в обычное состояние
            self.create_btn.config(state=tk.DISABLED, text="Создать файлы", command=self.create_files)
            
            # Автоматически запускаем валидацию
            self.validate_file()
        
        # Возвращаем фокус на окно создания файлов
        self.window.lift()
        self.window.focus_force()

    def _reset_state(self):
        """Полный сброс состояния окна"""
        self.output_dir_path = ""
        self.output_dir_var.set("")
        self.new_employees_count = 0
        self.skip_employees_count = 0
        self.validation_result = None
        self.existing_files_info = {}
        if hasattr(self, '_employees'):
            delattr(self, '_employees')

    def select_output_dir(self):
        """Выбор целевой папки"""
        dir_path = filedialog.askdirectory(
            title="Выберите целевую папку для создания файлов сотрудников"
        )
        
        if dir_path:
            self.output_dir_path = dir_path
            self.output_dir_var.set(dir_path)
            self.add_info(f"Выбрана целевая папка: {dir_path}")
            
            # ВАЖНО: сбрасываем кнопку создания в обычное состояние
            self.create_btn.config(state=tk.DISABLED, text="Создать файлы", command=self.create_files)
            
            # Проверяем существующие файлы
            self.add_info("")
            self.add_info("Анализ целевой папки...")
            self.check_existing_files(dir_path)
            
            # Проверяем возможность активации кнопки создания
            self.check_create_button_state()
        
        # Возвращаем фокус на окно создания файлов
        self.window.lift()
        self.window.focus_force()

    def check_existing_files(self, dir_path):
        """Проверяет существующие файлы в папке и выводит подробную статистику"""
        try:
            base_path = Path(dir_path)
            if not base_path.exists():
                self.add_info("Папка не существует")
                return
            
            # Проверяем что данные сотрудников загружены
            if not (self.validation_result and hasattr(self, '_employees') and self._employees):
                self.add_info("Ошибка: данные сотрудников не загружены")
                return
            
            # Получаем ожидаемые отделы из валидации
            expected_departments = set()
            for emp in self._employees:
                if emp.department1:
                    clean_dept = self._clean_directory_name(emp.department1)
                    expected_departments.add((emp.department1, clean_dept))
            
            existing_departments = []
            new_departments = []
            total_existing_employees = 0
            existing_employees_by_dept = {}
            departments_with_files = 0
            
            # Сканируем папки
            for item in base_path.iterdir():
                if item.is_dir():
                    # Проверяем, является ли папка ожидаемым отделом
                    for orig_dept, clean_dept in expected_departments:
                        if item.name == clean_dept:
                            existing_departments.append(orig_dept)
                            
                            # Подсчитываем файлы в этой папке
                            dept_files = 0
                            for file_item in item.iterdir():
                                if file_item.is_file() and file_item.suffix.lower() == '.xlsx':
                                    # Исключаем отчеты
                                    if not file_item.name.startswith('!'):
                                        dept_files += 1
                            
                            existing_employees_by_dept[orig_dept] = dept_files
                            total_existing_employees += dept_files
                            if dept_files > 0:
                                departments_with_files += 1
                            break
            
            # Определяем новые отделы
            all_departments_from_file = set(emp.department1 for emp in self._employees if emp.department1)
            new_departments = list(all_departments_from_file - set(existing_departments))
            
            # Подсчитываем новых сотрудников
            self.new_employees_count = max(0, len(self._employees) - total_existing_employees)
            self.skip_employees_count = total_existing_employees
            
            # Выводим информацию в новом формате
            if existing_departments or new_departments:
                self.add_info("Файлы по сотрудникам не будут переписаны, но \"долив\" в существующие папки сотрудников будет выполнен", "warning")
                
                # Списки отделов в одну строку через запятую
                if existing_departments:
                    existing_list = ", ".join(existing_departments)
                    self.add_info(f"Существующие отделы: {existing_list}")
                
                if new_departments:
                    new_list = ", ".join(new_departments)
                    self.add_info(f"Новые отделы: {new_list}")
                
                if self.new_employees_count > 0:
                    self.add_info(f"Будет добавлено {self.new_employees_count} новых сотр., остальные {self.skip_employees_count} сотр. уже есть")
                    if self.skip_employees_count > 0:
                        self.add_info("Если требуется их переписать - удалите старые файлы вручную")
                    
                    # Статистика
                    self.add_info("")
                    self.add_info("ПЛАН ОБРАБОТКИ:", "success")
                    self.add_info(f"  • Будет создано: {self.new_employees_count} сотр.")
                    self.add_info(f"  • Будет пропущено: {self.skip_employees_count} сотр.")
                    self.add_info(f"  • Всего сотрудников: {len(self._employees)}")
                    
                    # Рассчитываем ожидаемое время
                    if self.validation_result:
                        estimated_time = max(0.1, self.new_employees_count * self.config.get("processing_time_per_file", 0.3))
                        self.add_info(f"  • Ожидаемое время: {estimated_time:.1f} сек")
                    
                    # Следующие шаги
                    self.add_info("")
                    self.add_info("Для продолжения нажмите кнопку 'Создать файлы'", "success")
                else:
                    self.add_info("Все записи уже есть в папке - новых файлов создаваться не будет")
                    self.new_employees_count = 0
            else:
                # Новая структура
                self.new_employees_count = len(self._employees)
                self.skip_employees_count = 0
                
                # Все отделы новые
                all_departments = list(set(emp.department1 for emp in self._employees if emp.department1))
                new_list = ", ".join(all_departments)
                
                self.add_info("В папке нет подразделений из вашего файла - будет создана новая структура")
                self.add_info(f"Новые отделы: {new_list}")
                
                self.add_info("")
                self.add_info("ПЛАН ОБРАБОТКИ:", "success")
                self.add_info(f"  • Будет создано: {self.new_employees_count} сотр.")
                self.add_info(f"  • Будет пропущено: {self.skip_employees_count} сотр.")
                self.add_info(f"  • Всего сотрудников: {len(self._employees)}")
                
                # Рассчитываем ожидаемое время для всех файлов
                estimated_time = max(0.1, self.new_employees_count * self.config.get("processing_time_per_file", 0.3))
                self.add_info(f"  • Ожидаемое время: {estimated_time:.1f} сек")
                
                # Следующие шаги
                self.add_info("")
                self.add_info("Для продолжения нажмите кнопку 'Создать файлы'", "success")
            
            # Сохраняем информацию для использования в процессоре
            self.existing_files_info = {
                'departments': existing_departments,
                'files_count': total_existing_employees,
                'by_department': existing_employees_by_dept
            }
                
        except Exception as e:
            self.add_info(f"Ошибка проверки папки: {e}", "error")
    
    def validate_file(self):
        """Валидация выбранного файла"""
        if not self.staff_file_path:
            return
        
        self.add_info("Начало валидации файла...")
        
        # Запускаем валидацию в отдельном потоке
        def validate_thread():
            try:
                validation_result, employees = self.processor.validator.validate_staff_file(self.staff_file_path)
                
                # Сохраняем результат для использования
                self.validation_result = validation_result
                
                # Обновляем UI в главном потоке
                self.window.after(0, self.on_validation_complete, employees)
                
            except Exception as e:
                self.window.after(0, self.on_validation_error, str(e))
        
        threading.Thread(target=validate_thread, daemon=True).start()
    
    def on_validation_complete(self, employees):
        """Обработчик завершения валидации"""
        # Сохраняем сотрудников для проверки отделов и уникальности
        self._employees = employees
        
        if self.validation_result.is_valid:
            self.add_info("")
            self.add_info("ВАЛИДАЦИЯ УСПЕШНО ЗАВЕРШЕНА", "success")
            
            # Проверяем уникальность табельных номеров и отделов
            unique_check = self.check_employee_uniqueness(employees)
            if not unique_check['is_valid']:
                self.add_info("")
                self.add_info("НАЙДЕНЫ ПРОБЛЕМЫ:", "warning")
                for error in unique_check['errors']:
                    self.add_info(f"  • {error}", "warning")
            
            self.add_info("")
            self.add_info("СТАТИСТИКА ФАЙЛА:", "success")
            stats_lines = self.format_validation_stats(self.validation_result, employees).split('\n')
            for line in stats_lines:
                if line.strip():
                    self.add_info(f"  {line.strip()}")
            
            # Если уже выбрана папка, перепроверяем ее
            if self.output_dir_path:
                self.add_info("")
                self.add_info("Анализ целевой папки...")
                self.check_existing_files(self.output_dir_path)
            else:
                self.add_info("")
                self.add_info("Выберите целевую папку для создания файлов сотрудников")
            
            # Проверяем возможность активации кнопки создания
            self.check_create_button_state()
            
        else:
            self.add_info("")
            self.add_info("ВАЛИДАЦИЯ ВЫЯВИЛА ОШИБКИ", "error")
            
            self.add_info("")
            self.add_info("ОШИБКИ ВАЛИДАЦИИ:", "error")
            for error in self.validation_result.errors:
                self.add_info(f"  • {error}", "error")
            
            if self.validation_result.warnings:
                self.add_info("")
                self.add_info("ПРЕДУПРЕЖДЕНИЯ:", "warning")
                for warning in self.validation_result.warnings:
                    self.add_info(f"  • {warning}", "warning")
    
    def check_employee_uniqueness(self, employees):
        """Проверяет уникальность сотрудников по табельному номеру и отделам"""
        result = {'is_valid': True, 'errors': []}
        
        # Проверяем уникальность табельных номеров
        tab_numbers = {}
        for emp in employees:
            if emp.tab_number in tab_numbers:
                tab_numbers[emp.tab_number].append(emp.full_name)
            else:
                tab_numbers[emp.tab_number] = [emp.full_name]
        
        for tab_num, names in tab_numbers.items():
            if len(names) > 1:
                result['is_valid'] = False
                result['errors'].append(f"Дублирующийся табельный номер {tab_num}: {', '.join(names)}")
        
        # Проверяем, что один сотрудник не находится в разных отделах
        employee_departments = {}
        for emp in employees:
            key = f"{emp.full_name}_{emp.tab_number}"
            if key in employee_departments:
                if employee_departments[key] != emp.department1:
                    result['is_valid'] = False
                    result['errors'].append(f"Сотрудник {emp.full_name} ({emp.tab_number}) находится в разных подразделениях: {employee_departments[key]} и {emp.department1}")
            else:
                employee_departments[key] = emp.department1
        
        return result
    
    def on_validation_error(self, error_message):
        """Обработчик ошибки валидации"""
        self.add_info(f"Ошибка валидации: {error_message}", "error")
        messagebox.showerror("Ошибка валидации", error_message)
    
    def format_validation_stats(self, validation_result, employees):
        """Форматирует статистику валидации"""
        stats = f"СТАТИСТИКА ФАЙЛА:\n"
        stats += f"• Всего сотрудников: {validation_result.employee_count}\n"
        stats += f"• Уникальных табельных номеров: {validation_result.unique_tab_numbers}\n"
        
        if validation_result.warnings:
            stats += f"• Предупреждений: {len(validation_result.warnings)}"
        
        return stats
    
    def _clean_directory_name(self, name: str) -> str:
        """Очищает имя папки от недопустимых символов"""
        if not name:
            return "unnamed"
        
        invalid_chars = r'[<>:"/\\|?*]'
        clean_name = re.sub(invalid_chars, '_', name)
        clean_name = clean_name.strip('. ')
        
        if len(clean_name) > 100:
            clean_name = clean_name[:100]
        
        return clean_name or "unnamed"

    def check_create_button_state(self):
        """Проверяет и обновляет состояние кнопки создания файлов"""
        # Кнопка активна только если:
        # 1. Валидация прошла успешно
        # 2. Выбрана целевая папка
        # 3. Есть сотрудники для обработки (new_employees_count > 0)
        # 4. Не идет процесс обработки
        # 5. Кнопка еще не в состоянии "Закрыть"
        if (self.validation_result and 
            self.validation_result.is_valid and 
            self.output_dir_path and 
            hasattr(self, 'new_employees_count') and
            self.new_employees_count > 0 and
            not self.is_processing and
            self.create_btn['text'] != "Закрыть"):
            
            self.create_btn.config(state=tk.NORMAL, text="Создать файлы", command=self.create_files)
        elif self.create_btn['text'] != "Закрыть":
            self.create_btn.config(state=tk.DISABLED)
    
    def create_files(self):
        """Создание файлов сотрудников"""
        if not self.validation_result or not self.validation_result.is_valid:
            messagebox.showwarning("Предупреждение", "Сначала выполните валидацию файла")
            return
        
        if not self.output_dir_path:
            messagebox.showwarning("Предупреждение", "Выберите целевую папку")
            return
        
        if not hasattr(self, 'new_employees_count') or self.new_employees_count <= 0:
            messagebox.showwarning("Предупреждение", "Нет новых записей для создания")
            return
        
        self.start_processing()
    
    def start_processing(self):
        """Начинает процесс создания файлов"""
        self.is_processing = True
        self.create_btn.config(state=tk.DISABLED)
        
        # Переключаемся на отображение прогресса
        self.show_progress_view()
        
        self.add_info("Начало создания файлов...")
        
        def processing_thread():
            try:
                # Используем исправленный метод процессора
                operation_log = self.processor.create_employee_files_to_existing(
                    self.staff_file_path,
                    self.output_dir_path,
                    self.on_progress_update,
                    self.on_department_progress_update,
                    self.on_file_progress_update
                )
                
                # Завершение в главном потоке
                self.window.after(0, self.on_processing_complete, operation_log)
                
            except Exception as e:
                self.window.after(0, self.on_processing_error, str(e))
        
        threading.Thread(target=processing_thread, daemon=True).start()
    
    def show_progress_view(self):
        """Показывает область прогресса вместо информации"""
        self.info_frame.grid_remove()
        self.progress_frame.grid(row=1, column=0, columnspan=3, pady=(0, 10), sticky=(tk.W, tk.E, tk.N, tk.S))
    
    def show_info_view(self):
        """Показывает область информации вместо прогресса"""
        self.progress_frame.grid_remove()
        self.info_frame.grid(row=1, column=0, columnspan=3, pady=(0, 10), sticky=(tk.W, tk.E, tk.N, tk.S))
    
    def on_progress_update(self, progress):
        """Обработчик обновления общего прогресса"""
        def update_ui():
            # Общий процент
            if progress.total_files > 0:
                overall_percent = (progress.processed_files / progress.total_files) * 100
                self.overall_progress_label.config(text=f"Общий прогресс: {overall_percent:.1f}%")
            
            # Время
            elapsed = (datetime.now() - progress.start_time).total_seconds()
            if progress.processed_files > 0 and progress.total_files > 0:
                speed = progress.processed_files / elapsed  # файлов в секунду
                remaining_files = progress.total_files - progress.processed_files
                remaining_time = remaining_files / speed if speed > 0 else 0
                self.time_label.config(
                    text=f"Прошло: {elapsed:.0f} сек, Осталось: {remaining_time:.0f} сек"
                )
            else:
                self.time_label.config(text=f"Прошло: {elapsed:.0f} сек")
        
        self.window.after(0, update_ui)
    
    def on_department_progress_update(self, current_dept, total_depts, dept_name):
        """Обработчик обновления прогресса по отделам"""
        def update_ui():
            if total_depts > 0:
                dept_percent = (current_dept / total_depts) * 100
                self.departments_progress_bar['value'] = dept_percent
                self.departments_detail_label.config(
                    text=f"Отдел {current_dept}/{total_depts}: {dept_name}"
                )
        
        self.window.after(0, update_ui)
    
    def on_file_progress_update(self, current_file, total_files, file_info):
        """Обработчик обновления прогресса по файлам в текущем отделе"""
        def update_ui():
            if total_files > 0:
                file_percent = (current_file / total_files) * 100
                self.employees_progress_bar['value'] = file_percent
                self.employees_detail_label.config(
                    text=f"Файл {current_file}/{total_files}: {file_info}"
                )
        
        self.window.after(0, update_ui)
    
    def on_processing_complete(self, operation_log):
        """Обработчик завершения создания файлов"""
        self.is_processing = False
        
        if operation_log.status == ProcessingStatus.SUCCESS:
            # Добавляем результат в существующую информацию
            self.add_info_to_existing("")
            self.add_info_to_existing("=" * 50)
            self.add_info_to_existing("СОЗДАНИЕ ФАЙЛОВ УСПЕШНО ЗАВЕРШЕНО!", "success")
            self.add_info_to_existing(f"Время выполнения: {operation_log.duration:.1f} сек")
            self.add_info_to_existing("=" * 50)
            self.add_info_to_existing("")
            
            # Добавляем информацию о результатах операции
            for entry in operation_log.entries:
                if entry.level == "INFO":
                    if "Создано:" in entry.message or "создано" in entry.message.lower():
                        message = entry.message
                        if "из" in message and "сотрудников" in message:
                            message = message.replace("сотрудников", "сотр.")
                        self.add_info_to_existing(f"ИТОГ: {message}", "success")
                    else:
                        self.add_info_to_existing(f"  • {entry.message}")
            
            # Возвращаемся к отображению информации
            self.show_info_view()
            
            # ИСПРАВЛЕНИЕ: Всегда показываем кнопку "Закрыть"
            self.create_btn.config(text="Закрыть", command=self.on_closing, state=tk.NORMAL)
            
        else:
            self.add_info_to_existing("")
            self.add_info_to_existing("СОЗДАНИЕ ФАЙЛОВ ЗАВЕРШЕНО С ОШИБКАМИ!", "error")
            
            # Показываем ошибки
            for entry in operation_log.entries:
                if entry.level == "ERROR":
                    self.add_info_to_existing(f"ОШИБКА: {entry.message}", "error")
            
            # Возвращаемся к отображению информации
            self.show_info_view()
            self.create_btn.config(text="Закрыть", command=self.on_closing, state=tk.NORMAL)
            
            # Показываем messagebox с ошибкой
            messagebox.showerror("Ошибка создания файлов", "Создание файлов завершено с ошибками. См. подробности в окне.")


    def on_processing_error(self, error_message):
        """Обработчик ошибки создания файлов"""
        self.is_processing = False
        self.create_btn.config(text="Закрыть", command=self.on_closing, state=tk.NORMAL)
        
        self.add_info(f"Критическая ошибка: {error_message}", "error")
        messagebox.showerror("Критическая ошибка", error_message)
        
        # Возвращаемся к отображению информации
        self.show_info_view()
    
    def copy_selected_text(self):
        """Копирует выделенный текст в буфер обмена"""
        try:
            selected_text = self.info_text.selection_get()
            self.info_text.clipboard_clear()
            self.info_text.clipboard_append(selected_text)
        except tk.TclError:
            # Если ничего не выделено, копируем весь текст
            all_text = self.info_text.get("1.0", "end-1c")
            self.info_text.clipboard_clear()
            self.info_text.clipboard_append(all_text)
    
    def add_info(self, message: str, level: str = "info"):
        """Добавляет информационное сообщение"""
        from datetime import datetime
        
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        # Определяем цвет и стиль для разных уровней
        # Красный или зеленый цвет и всегда жирный шрифт для важных сообщений
        if level in ["success", "error", "warning"]:
            colors = {
                "warning": "#FF8C00",
                "error": "red",
                "success": "green"
            }
            color = colors[level]
            font_style = ("TkDefaultFont", 9, "bold")
        else:
            color = "black"
            font_style = ("TkDefaultFont", 9)
        
        # Вставляем текст
        if message.strip():  # Только если сообщение не пустое
            self.info_text.insert(tk.END, f"[{timestamp}] {message}\n")
        else:
            self.info_text.insert(tk.END, "\n")
        
        # Применяем цвет и стиль к последней строке
        if level in ["success", "error", "warning"]:
            start_line = self.info_text.index(tk.END + "-2l linestart")
            end_line = self.info_text.index(tk.END + "-1l lineend")
            
            tag_name = f"color_{level}_{timestamp}"
            self.info_text.tag_add(tag_name, start_line, end_line)
            self.info_text.tag_config(tag_name, foreground=color, font=font_style)
        
        # Прокручиваем в конец
        self.info_text.see(tk.END)
        
        # Обновляем интерфейс
        self.parent.update_idletasks()
    
    def add_info_to_existing(self, message: str, level: str = "info"):
        """Добавляет информацию в существующий текст без временной метки"""
        # Определяем цвет и стиль для разных уровней
        # Красный или зеленый цвет и всегда жирный шрифт для важных сообщений
        if level in ["success", "error", "warning"]:
            colors = {
                "warning": "#FF8C00",
                "error": "red", 
                "success": "green"
            }
            color = colors[level]
            font_style = ("TkDefaultFont", 9, "bold")
        else:
            color = "black"
            font_style = ("TkDefaultFont", 9)
        
        # Вставляем текст
        if message.strip():  # Только если сообщение не пустое
            self.info_text.insert(tk.END, f"{message}\n")
        else:
            self.info_text.insert(tk.END, "\n")
        
        # Применяем цвет и стиль к последней строке
        if level in ["success", "error", "warning"]:
            start_line = self.info_text.index(tk.END + "-2l linestart")
            end_line = self.info_text.index(tk.END + "-1l lineend")
            
            tag_name = f"color_{level}_no_time"
            self.info_text.tag_add(tag_name, start_line, end_line)
            self.info_text.tag_config(tag_name, foreground=color, font=font_style)
        
        # Прокручиваем в конец
        self.info_text.see(tk.END)
        
        # Обновляем интерфейс
        self.parent.update_idletasks()
    
    def add_log(self, message: str, level: str = "info"):
        """Добавляет сообщение в лог (совместимость со старым кодом)"""
        self.add_info(message, level)
        
        # Также отправляем в главное окно
        if self.main_window:
            if hasattr(self.main_window, 'add_info'):
                self.main_window.add_info(f"Создание файлов: {message}", level)
    

    def restart_process(self):
        """Перезапуск процесса создания файлов"""
        # Сбрасываем состояние обработки
        self.is_processing = False
        
        # Очищаем информацию
        self.info_text.delete(1.0, tk.END)
        self.add_info("Готов к повторному запуску")
        
        # Если есть валидные данные - проверяем возможность создания
        if (self.validation_result and 
            self.validation_result.is_valid and 
            self.output_dir_path):
            
            # Перепроверяем папку
            self.add_info("")
            self.add_info("Повторный анализ целевой папки...")
            self.check_existing_files(self.output_dir_path)
            self.check_create_button_state()
        else:
            self.add_info("Выберите файл с сотрудниками и целевую папку для начала работы")
            self.create_btn.config(state=tk.DISABLED, text="Создать файлы", command=self.create_files)

    def on_closing(self):
        """Обработчик закрытия окна"""
        if self.is_processing:
            result = messagebox.askyesno(
                "Подтверждение",
                "Идет процесс создания файлов. Действительно закрыть окно?"
            )
            if not result:
                return
        
        self.window.destroy()
        if self.main_window:
            self.main_window.on_window_closed("create_files")



=============================================
FILE: D:\Users\chernousov-am\vp on pt\gui\main_window.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Главное окно приложения
"""

import tkinter as tk
from tkinter import ttk, messagebox
import logging
from pathlib import Path
from typing import Optional

from config import Config
from core.processor import VacationProcessor
from gui.create_files_window import CreateFilesWindow
from gui.reports_window import ReportsWindow


class MainWindow:
    """Главное окно приложения Vacation Tool"""
    
    def __init__(self, root: tk.Tk, config: Config):
        self.root = root
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.processor = VacationProcessor(config)
        
        # Дочерние окна
        self.create_files_window: Optional[CreateFilesWindow] = None
        self.reports_window: Optional[ReportsWindow] = None
        
        # Переменная для отслеживания состояния шаблонов
        self.templates_ok = False
        
        self.setup_ui()
        self.check_templates()
        
        # Настраиваем периодическую проверку шаблонов
        self.schedule_template_check()
    
    def setup_ui(self):
        """Настройка пользовательского интерфейса"""
        # Запрещаем изменение размера окна
        self.root.resizable(False, False)
        
        # Основной фрейм
        main_frame = ttk.Frame(self.root, padding="16")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Настройка сетки
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(2, weight=1)  # Инструкции растягиваются
        
        # Информация о шаблонах
        self.templates_frame = ttk.LabelFrame(main_frame, text="Статус шаблонов", padding="10")
        self.templates_frame.grid(row=0, column=0, columnspan=2, pady=(0, 15), sticky=(tk.W, tk.E))
        self.templates_frame.columnconfigure(1, weight=1)
        
        self.template_status = {}
        templates = [
            ("Шаблон сотрудника:", self.config.employee_template),
            ("Шаблон отчета по блоку:", self.config.block_report_template),
            ("Шаблон общего отчета:", self.config.general_report_template)
        ]
        
        for i, (label_text, template_path) in enumerate(templates):
            # Метка
            label = ttk.Label(self.templates_frame, text=label_text)
            label.grid(row=i, column=0, sticky=tk.W, pady=0)
            
            # Путь к файлу
            path_label = ttk.Label(self.templates_frame, text=template_path, foreground="blue")
            path_label.grid(row=i, column=1, sticky=(tk.W, tk.E), padx=(10, 0), pady=0)
            
            # Статус
            status_label = ttk.Label(self.templates_frame, text="", foreground="red")
            status_label.grid(row=i, column=2, sticky=tk.E, padx=(10, 0), pady=0)

            self.template_status[template_path] = status_label
        
        # Кнопки основных функций
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.grid(row=1, column=0, columnspan=2, pady=(0, 15), sticky=(tk.W, tk.E))
        buttons_frame.columnconfigure(0, weight=1)
        buttons_frame.columnconfigure(1, weight=1)
        
        # Настраиваем стиль для больших кнопок
        style = ttk.Style()
        style.configure("BigButton.TButton", padding=(10, 15))
        
        # Кнопка создания файлов
        self.create_files_btn = ttk.Button(
            buttons_frame,
            text="Создание файлов",
            command=self.open_create_files_window,
            width=25,
            style="BigButton.TButton"
        )
        self.create_files_btn.grid(row=0, column=0, padx=(0, 10), pady=0, sticky=(tk.W, tk.E))
        
        # Кнопка работы с отчетами
        self.reports_btn = ttk.Button(
            buttons_frame,
            text="Работа с отчетами",
            command=self.open_reports_window,
            width=25,
            style="BigButton.TButton"
        )
        self.reports_btn.grid(row=0, column=1, padx=(10, 0), pady=0, sticky=(tk.W, tk.E))
        
        # Инструкции и статус
        instructions_frame = ttk.LabelFrame(main_frame, text="Инструкции", padding="10")
        instructions_frame.grid(row=2, column=0, columnspan=2, pady=(0, 0), sticky=(tk.W, tk.E, tk.N, tk.S))
        instructions_frame.columnconfigure(0, weight=1)
        instructions_frame.rowconfigure(0, weight=1)
        
        # Текст инструкций с возможностью копирования
        self.instructions_text = tk.Text(
            instructions_frame,
            wrap=tk.WORD,
            font=("TkDefaultFont", 9),
            state=tk.NORMAL,
            bg=self.root.cget('bg'),
            relief=tk.FLAT,
            cursor="arrow"
        )
        
        # Настройка копирования
        def on_key(event):
            # Разрешаем только копирование
            if event.state & 0x4:  # Ctrl нажат
                if event.keysym.lower() in ['c', 'a']:
                    return  # Разрешаем Ctrl+C и Ctrl+A
            return "break"  # Блокируем все остальные клавиши
        
        self.instructions_text.bind('<Key>', on_key)
        self.instructions_text.bind('<Control-a>', lambda e: self.instructions_text.tag_add("sel", "1.0", "end"))
        
        # Контекстное меню для копирования
        def show_context_menu(event):
            try:
                context_menu = tk.Menu(self.instructions_text, tearoff=0)
                context_menu.add_command(label="Выделить всё", command=lambda: self.instructions_text.tag_add("sel", "1.0", "end"))
                context_menu.add_command(label="Копировать", command=lambda: self.copy_selected_text())
                context_menu.tk_popup(event.x_root, event.y_root)
            except:
                pass
        
        self.instructions_text.bind('<Button-3>', show_context_menu)  # Правая кнопка мыши
        
        # Добавляем скроллбар
        scrollbar = ttk.Scrollbar(instructions_frame, orient=tk.VERTICAL, command=self.instructions_text.yview)
        self.instructions_text.configure(yscrollcommand=scrollbar.set)
        
        self.instructions_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # Вставляем инструкции
        self.insert_instructions()
        self.instructions_text.config(state=tk.DISABLED)
    
    def copy_selected_text(self):
        """Копирует выделенный текст в буфер обмена"""
        try:
            selected_text = self.instructions_text.selection_get()
            self.instructions_text.clipboard_clear()
            self.instructions_text.clipboard_append(selected_text)
        except tk.TclError:
            # Если ничего не выделено, копируем весь текст
            all_text = self.instructions_text.get("1.0", "end-1c")
            self.instructions_text.clipboard_clear()
            self.instructions_text.clipboard_append(all_text)
    
    def check_templates(self):
        """Проверяет наличие шаблонов и обновляет состояние кнопок"""
        validation_result = self.processor.validator.validate_templates()
        
        all_found = True
        missing_templates = []
        
        for template_path, status_label in self.template_status.items():
            if Path(template_path).exists():
                status_label.config(text="Найден", foreground="green")
            else:
                status_label.config(text="Отсутствует", foreground="red")
                all_found = False
                missing_templates.append(Path(template_path).name)
        
        # Обновляем состояние только если изменилось
        if all_found != self.templates_ok:
            self.templates_ok = all_found
            
            if all_found:
                self.templates_frame.config(text="Статус шаблонов: все найдены, функции доступны")
                self.create_files_btn.config(state=tk.NORMAL)
                self.reports_btn.config(state=tk.NORMAL)
            else:
                missing_list = ", ".join(missing_templates)
                self.templates_frame.config(text=f"Статус шаблонов: отсутствуют {missing_list}")
                self.create_files_btn.config(state=tk.DISABLED)
                self.reports_btn.config(state=tk.DISABLED)
    
    def insert_instructions(self):
        """Вставляет базовые инструкции"""
        instructions_text = """1. СОЗДАНИЕ ФАЙЛОВ ОТПУСКОВ:
   • Подготовьте Excel файл с данными сотрудников
   • Заголовки должны быть в 5-й строке файла
   • Обязательные столбцы: "ФИО работника", "Табельный номер", "Подразделение 1", "Подразделение 2", "Подразделение 3", "Подразделение 4"
   • Нажмите "Создание файлов" для начала работы

2. РАБОТА С ОТЧЕТАМИ:
   • Обновление отчетов по подразделениям на основе заполненных файлов сотрудников
   • Создание общего отчета по всей компании
   • Нажмите "Работа с отчетами" для начала

3. ТРЕБОВАНИЯ К ШАБЛОНАМ:
   • Все шаблоны должны находиться в папке templates/
   • При отсутствии шаблонов функции будут недоступны
   • Шаблоны должны иметь название: employee_template.xlsx, block_report_template.xlsx, global_report_template.xlsx"""
        
        self.instructions_text.insert(tk.END, instructions_text)
    
    def open_create_files_window(self):
        """Открывает окно создания файлов"""
        try:
            # Проверяем, есть ли уже открытое окно
            if self.create_files_window and self.create_files_window.window and self.create_files_window.window.winfo_exists():
                # Окно уже открыто, просто активируем его
                self.create_files_window.show()
                return
            
            # Создаем новое окно
            self.create_files_window = CreateFilesWindow(self.root, self.config, self)
            self.create_files_window.show()
            
        except Exception as e:
            self.logger.error(f"Ошибка открытия окна создания файлов: {e}")
            messagebox.showerror("Ошибка", f"Не удалось открыть окно создания файлов: {e}")
    
    def open_reports_window(self):
        """Открывает окно работы с отчетами"""
        try:
            # Проверяем, есть ли уже открытое окно
            if self.reports_window and self.reports_window.window and self.reports_window.window.winfo_exists():
                # Окно уже открыто, просто активируем его
                self.reports_window.show()
                return
            
            # Создаем новое окно
            self.reports_window = ReportsWindow(self.root, self.config, self)
            self.reports_window.show()
            
        except Exception as e:
            self.logger.error(f"Ошибка открытия окна отчетов: {e}")
            messagebox.showerror("Ошибка", f"Не удалось открыть окно отчетов: {e}")
    
    def schedule_template_check(self):
        """Планирует периодическую проверку шаблонов"""
        self.check_templates()
        # Проверяем каждые 5 секунд
        self.root.after(5000, self.schedule_template_check)
    
    def on_window_closed(self, window_type: str):
        """Обработчик закрытия дочерних окон"""
        if window_type == "create_files":
            self.create_files_window = None
            # Обновляем статус шаблонов при возврате
            self.check_templates()
        elif window_type == "reports":
            self.reports_window = None

    def add_info(self, message: str, level: str = "info"):
        """Добавляет информацию (для совместимости с дочерними окнами)"""
        # Эта функция нужна для совместимости с create_files_window
        pass



=============================================
FILE: D:\Users\chernousov-am\vp on pt\gui\reports_window.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Окно работы с отчетами
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import threading
import logging
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime
import time

from config import Config
from core.processor import VacationProcessor
from models import ProcessingProgress, ProcessingStatus


class ReportTab:
    """Базовый класс для вкладок отчетов"""
    
    def __init__(self, parent_frame, config, processor, tab_type):
        """Конструктор вкладки отчетов"""
        self.frame = parent_frame
        self.config = config
        self.processor = processor
        self.tab_type = tab_type  # "departments" или "general"
        
        # Состояние
        self.target_path = ""
        self.scan_data = {}
        self.is_processing = False
        self.selected_departments = []
        
        # НОВЫЕ ПЕРЕМЕННЫЕ для отслеживания повторных выборов
        self.path_reselected = False
        
        self.setup_tab_ui()
    
    def add_info(self, message: str, level: str = "info"):
        """Добавляет информационное сообщение"""
        # ИСПРАВЛЕНИЕ: Проверяем что виджет еще существует
        try:
            if not self.info_text.winfo_exists():
                return
        except tk.TclError:
            return
        
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        if level in ["success", "error", "warning"]:
            colors = {"warning": "#FF8C00", "error": "red", "success": "green"}
            color = colors[level]
            font_style = ("TkDefaultFont", 9, "bold")
        else:
            color = "black"
            font_style = ("TkDefaultFont", 9)
        
        if message.strip():
            self.info_text.insert(tk.END, f"[{timestamp}] {message}\n")
        else:
            self.info_text.insert(tk.END, "\n")
        
        if level in ["success", "error", "warning"]:
            start_line = self.info_text.index(tk.END + "-2l linestart")
            end_line = self.info_text.index(tk.END + "-1l lineend")
            tag_name = f"color_{level}_{timestamp}"
            self.info_text.tag_add(tag_name, start_line, end_line)
            self.info_text.tag_config(tag_name, foreground=color, font=font_style)
        
        self.info_text.see(tk.END)

    def restart_process(self):
        """Перезапуск процесса создания отчетов"""
        # Сбрасываем состояние обработки
        self.is_processing = False
        
        # Очищаем информацию
        self.info_text.delete(1.0, tk.END)
        initial_msg = "Готов к повторному созданию отчетов по подразделениям" if self.tab_type == "departments" else "Готов к повторному созданию общего отчета"
        self.add_info(initial_msg)
        
        # Если есть валидные данные - проверяем возможность создания
        if self.scan_data and self.selected_departments:
            self.add_info("")
            self.add_info("Данные для обработки готовы")
            
            # Показываем выбранные подразделения
            total_departments = len(self.scan_data)
            total_files = sum(self.scan_data.values())
            
            self.add_info("Выбранные подразделения:", "success")
            for dept in self.selected_departments:
                self.add_info(f"  • {dept['name']}: {dept['files_count']} файлов")
            
            self.add_info("")
            self.add_info("Статистика обработки:", "success")
            self.add_info(f"  • Подразделений: {total_departments}")
            self.add_info(f"  • Файлов сотрудников: {total_files}")
            
            # Активируем кнопку
            btn_text = "Создать отчеты по подразделениям" if self.tab_type == "departments" else "Создать общий отчет"
            self.action_btn.config(text=btn_text, command=self.start_processing, state=tk.NORMAL)
        else:
            initial_msg = "Выберите папки подразделений для создания отчетов" if self.tab_type == "departments" else "Выберите целевую папку для создания общего отчета"
            self.add_info(initial_msg)
            btn_text = "Создать отчеты по подразделениям" if self.tab_type == "departments" else "Создать общий отчет"
            self.action_btn.config(text=btn_text, command=self.start_processing, state=tk.DISABLED)

    def setup_tab_ui(self):
        """Настройка интерфейса вкладки"""
        self.frame.columnconfigure(1, weight=1)
        self.frame.rowconfigure(1, weight=1)
        
        # 1. Блок выбора
        self.setup_file_selection()
        
        # 2. Информация/прогресс
        self.setup_info_progress_area()
        
        # 3. Кнопки
        self.setup_control_buttons()
    
    def setup_file_selection(self):
        """Настройка области выбора"""
        title = "Выбор папок подразделений" if self.tab_type == "departments" else "Выбор целевой папки"
        label_text = "Папки подразделений:" if self.tab_type == "departments" else "Целевая папка:"
        
        files_frame = ttk.LabelFrame(self.frame, text=title, padding="10")
        files_frame.grid(row=0, column=0, columnspan=3, pady=(0, 15), sticky=(tk.W, tk.E))
        files_frame.columnconfigure(1, weight=1)
        
        ttk.Label(files_frame, text=label_text).grid(row=0, column=0, sticky=tk.W, pady=5)
        
        self.path_var = tk.StringVar()
        self.path_entry = ttk.Entry(files_frame, textvariable=self.path_var, state="readonly")
        self.path_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(10, 5), pady=5)
        
        self.select_btn = ttk.Button(files_frame, text="Выбрать", command=self.select_path)
        self.select_btn.grid(row=0, column=2, pady=5)
    
    def setup_info_progress_area(self):
        """Настройка области информации/прогресса"""
        # Информация (по умолчанию)
        self.info_frame = ttk.LabelFrame(self.frame, text="Информация", padding="10")
        self.info_frame.grid(row=1, column=0, columnspan=3, pady=(0, 15), sticky=(tk.W, tk.E, tk.N, tk.S))
        self.info_frame.columnconfigure(0, weight=1)
        self.info_frame.rowconfigure(0, weight=1)
        
        self.info_text = tk.Text(self.info_frame, height=12, wrap=tk.WORD, font=("TkDefaultFont", 9), 
                                state=tk.NORMAL, cursor="arrow")
        
        # Настройка копирования
        self.setup_text_copy_behavior(self.info_text)
        
        info_scrollbar = ttk.Scrollbar(self.info_frame, orient=tk.VERTICAL, command=self.info_text.yview)
        self.info_text.configure(yscrollcommand=info_scrollbar.set)
        
        self.info_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        info_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # Прогресс (скрыт)
        self.progress_frame = ttk.LabelFrame(self.frame, text="Прогресс обработки", padding="10")
        self.progress_frame.columnconfigure(0, weight=1)
        
        # Общий прогресс и время
        self.overall_progress_label = ttk.Label(self.progress_frame, text="Готов к началу", font=("TkDefaultFont", 10, "bold"))
        self.overall_progress_label.grid(row=0, column=0, sticky=tk.W, pady=2)
        
        self.time_label = ttk.Label(self.progress_frame, text="", font=("TkDefaultFont", 9))
        self.time_label.grid(row=1, column=0, sticky=tk.W, pady=2)
        
        # Прогресс подразделений
        label_text = "Подразделения:" if self.tab_type == "departments" else "Отделы:"
        ttk.Label(self.progress_frame, text=label_text, font=("TkDefaultFont", 9, "bold")).grid(row=2, column=0, sticky=tk.W, pady=(10, 2))
        self.dept_progress_bar = ttk.Progressbar(self.progress_frame, mode='determinate', length=400)
        self.dept_progress_bar.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=2)
        self.dept_detail_label = ttk.Label(self.progress_frame, text="", font=("TkDefaultFont", 8))
        self.dept_detail_label.grid(row=4, column=0, sticky=tk.W, pady=2)
        
        # Прогресс файлов
        files_label_text = "Файлы в текущем отделе:" if self.tab_type == "departments" else "Обработка отчетов:"
        ttk.Label(self.progress_frame, text=files_label_text, font=("TkDefaultFont", 9)).grid(row=5, column=0, sticky=tk.W, pady=(10, 2))
        self.files_progress_bar = ttk.Progressbar(self.progress_frame, mode='determinate', length=400)
        self.files_progress_bar.grid(row=6, column=0, sticky=(tk.W, tk.E), pady=2)
        self.files_detail_label = ttk.Label(self.progress_frame, text="", font=("TkDefaultFont", 8))
        self.files_detail_label.grid(row=7, column=0, sticky=tk.W, pady=2)
        
        # Инициализация
        initial_msg = "Выберите папки подразделений для создания отчетов" if self.tab_type == "departments" else "Выберите целевую папку для создания общего отчета"
        self.add_info(initial_msg)

    
    def setup_control_buttons(self):
        """Настройка кнопок управления"""
        buttons_frame = ttk.Frame(self.frame)
        buttons_frame.grid(row=2, column=0, columnspan=3, pady=(10, 15))
        buttons_frame.columnconfigure(0, weight=1)
        buttons_frame.columnconfigure(2, weight=1)
        
        btn_text = "Создать отчеты по подразделениям" if self.tab_type == "departments" else "Создать общий отчет"
        self.action_btn = ttk.Button(buttons_frame, text=btn_text, command=self.start_processing, state=tk.DISABLED)
        self.action_btn.grid(row=0, column=1)
    
    def setup_text_copy_behavior(self, text_widget):
        """Настройка поведения копирования для текстового виджета"""
        def on_key(event):
            if event.state & 0x4 and event.keysym.lower() in ['c', 'a']:
                return
            return "break"
        
        text_widget.bind('<Key>', on_key)
        text_widget.bind('<Control-a>', lambda e: text_widget.tag_add("sel", "1.0", "end"))
        
        def show_context_menu(event):
            try:
                context_menu = tk.Menu(text_widget, tearoff=0)
                context_menu.add_command(label="Выделить всё", command=lambda: text_widget.tag_add("sel", "1.0", "end"))
                context_menu.add_command(label="Копировать", command=lambda: self.copy_selected_text(text_widget))
                context_menu.tk_popup(event.x_root, event.y_root)
            except:
                pass
        
        text_widget.bind('<Button-3>', show_context_menu)
    
    def copy_selected_text(self, text_widget):
        """Копирует выделенный текст"""
        try:
            selected_text = text_widget.selection_get()
            text_widget.clipboard_clear()
            text_widget.clipboard_append(selected_text)
        except tk.TclError:
            all_text = text_widget.get("1.0", "end-1c")
            text_widget.clipboard_clear()
            text_widget.clipboard_append(all_text)
    
    def select_path(self):
        """Выбор пути"""
        dir_path = filedialog.askdirectory(title="Выберите папку с подразделениями")
        
        if not dir_path:
            self.frame.winfo_toplevel().lift()
            self.frame.winfo_toplevel().focus_force()
            return
        
        self.target_path = dir_path
        self.path_var.set(dir_path)
        self.add_info(f"Выбрана папка: {dir_path}")
        self.add_info("Сканирование папки...")
        
        # ИСПРАВЛЕНИЕ: Сбрасываем кнопку в ЗАКРЫТЬ если была завершена операция
        if self.action_btn['text'] == "Закрыть":
            # Отмечаем что был перевыбор и восстанавливаем кнопку действия qwe
            self.path_reselected = True
            btn_text = "Создать отчеты по подразделениям" if self.tab_type == "departments" else "Создать общий отчет"
            self.action_btn.config(state=tk.DISABLED, text=btn_text, command=self.start_processing)
        else:
            # Обычный сброс
            btn_text = "Создать отчеты по подразделениям" if self.tab_type == "departments" else "Создать общий отчет"
            self.action_btn.config(state=tk.DISABLED, text=btn_text, command=self.start_processing)
        
        def scan_thread():
            try:
                time.sleep(0.5)
                departments_info = self.processor.scan_target_directory(dir_path)
                
                if departments_info:
                    potential_departments = []
                    for dept_name, files_count in departments_info.items():
                        potential_departments.append({
                            'name': dept_name,
                            'path': str(Path(dir_path) / dept_name),
                            'files_count': files_count
                        })
                    
                    selected_departments = self.show_departments_selection_dialog(potential_departments)
                    
                    if selected_departments:
                        self.selected_departments = selected_departments
                        scan_data = {dept['name']: dept['files_count'] for dept in selected_departments}
                        self.frame.after(0, self.on_scan_complete, scan_data)
                    else:
                        return
                else:
                    self.frame.after(0, self.on_scan_complete, {})
            except Exception as e:
                self.frame.after(0, self.on_scan_error, str(e))
        
        threading.Thread(target=scan_thread, daemon=True).start()
        self.frame.winfo_toplevel().lift()
        self.frame.winfo_toplevel().focus_force()

    def show_departments_selection_dialog(self, departments):
        """Показывает диалог для выбора подразделений"""
        # Находим родительское окно
        parent_window = self.frame.winfo_toplevel()
        
        # Создаем модальное окно
        dialog = tk.Toplevel(parent_window)
        dialog.title("Выбор подразделений")
        dialog.geometry("600x500")
        dialog.resizable(True, True)
        dialog.transient(parent_window)
        dialog.grab_set()
        
        # Центрируем относительно родительского окна
        dialog.geometry("+%d+%d" % (
            parent_window.winfo_rootx() + 50,
            parent_window.winfo_rooty() + 50
        ))
        
        result = []
        
        # Основной фрейм
        main_frame = ttk.Frame(dialog, padding="15")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Заголовок
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 15))
        
        ttk.Label(
            header_frame,
            text="Выберите подразделения для создания отчетов:",
            font=("TkDefaultFont", 11, "bold")
        ).pack(anchor=tk.W)
        
        ttk.Label(
            header_frame,
            text=f"Найдено подразделений: {len(departments)}",
            font=("TkDefaultFont", 9)
        ).pack(anchor=tk.W, pady=(5, 0))
        
        # Область с чекбоксами
        list_frame = ttk.LabelFrame(main_frame, text="Подразделения", padding="10")
        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
        
        # Canvas для скроллинга
        canvas = tk.Canvas(list_frame)
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Переменные для чекбоксов
        dept_vars = {}
        
        # Создаем чекбоксы
        checkboxes = []
        for i, dept in enumerate(departments):
            var = tk.BooleanVar()
            var.set(True)  # По умолчанию все выбраны
            dept_vars[i] = var
            
            # Фрейм для чекбокса
            cb_frame = ttk.Frame(scrollable_frame)
            cb_frame.pack(fill=tk.X, pady=2)
            
            checkbox = ttk.Checkbutton(
                cb_frame,
                text=f"{dept['name']}",
                variable=var,
                width=40
            )
            checkbox.pack(side=tk.LEFT)
            checkboxes.append(checkbox)
            
            # Информация о файлах
            info_label = ttk.Label(
                cb_frame,
                text=f"({dept['files_count']} файлов)",
                font=("TkDefaultFont", 8),
                foreground="gray"
            )
            info_label.pack(side=tk.RIGHT)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Кнопки управления выбором
        selection_frame = ttk.Frame(main_frame)
        selection_frame.pack(fill=tk.X, pady=(0, 15))
        
        def select_all():
            for var in dept_vars.values():
                var.set(True)
        
        def deselect_all():
            for var in dept_vars.values():
                var.set(False)
        
        def get_selected_count():
            return sum(1 for var in dept_vars.values() if var.get())
        
        def update_selection_info():
            selected_count = get_selected_count()
            total_files = sum(departments[i]['files_count'] for i, var in dept_vars.items() if var.get())
            selection_info.config(text=f"Выбрано: {selected_count} подразделений, {total_files} файлов")
        
        # Кнопки выбора
        selection_buttons_frame = ttk.Frame(selection_frame)
        selection_buttons_frame.pack(side=tk.LEFT)
        
        ttk.Button(selection_buttons_frame, text="Выбрать все", command=lambda: [select_all(), update_selection_info()]).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(selection_buttons_frame, text="Снять выбор", command=lambda: [deselect_all(), update_selection_info()]).pack(side=tk.LEFT, padx=5)
        
        # Информация о выборе
        selection_info = ttk.Label(selection_frame, text="", font=("TkDefaultFont", 9, "bold"))
        selection_info.pack(side=tk.RIGHT)
        
        # Обновляем информацию при изменении чекбоксов
        for var in dept_vars.values():
            var.trace('w', lambda *args: update_selection_info())
        
        # Изначально обновляем информацию
        update_selection_info()
        
        # Кнопки диалога
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X)
        
        def on_ok():
            nonlocal result
            selected_indices = [i for i, var in dept_vars.items() if var.get()]
            if not selected_indices:
                messagebox.showwarning("Предупреждение", "Выберите хотя бы одно подразделение")
                return
            result = [departments[i] for i in selected_indices]
            dialog.destroy()
        
        def on_cancel():
            dialog.destroy()
        
        def on_dialog_close():
            """Обработчик закрытия диалога - возвращаем фокус на окно отчетов"""
            dialog.destroy()
            # ИСПРАВЛЕНИЕ: Возвращаем фокус на окно отчетов
            parent_window.lift()
            parent_window.focus_force()
        
        # Привязываем обработчик закрытия
        dialog.protocol("WM_DELETE_WINDOW", on_dialog_close)
        
        # Кнопки справа
        button_right_frame = ttk.Frame(buttons_frame)
        button_right_frame.pack(side=tk.RIGHT)
        
        def ok_and_focus():
            on_ok()
            # ИСПРАВЛЕНИЕ: Возвращаем фокус на окно отчетов после OK
            parent_window.lift()
            parent_window.focus_force()
        
        def cancel_and_focus():
            on_cancel()
            # ИСПРАВЛЕНИЕ: Возвращаем фокус на окно отчетов после Cancel
            parent_window.lift()
            parent_window.focus_force()
        
        ttk.Button(button_right_frame, text="OK", command=ok_and_focus).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_right_frame, text="Отмена", command=cancel_and_focus).pack(side=tk.LEFT)
        
        # Привязываем Enter и Escape
        dialog.bind('<Return>', lambda e: ok_and_focus())
        dialog.bind('<Escape>', lambda e: cancel_and_focus())
        
        # Фокус на первый чекбокс
        if checkboxes:
            checkboxes[0].focus_set()
        
        # Ждем закрытия диалога
        dialog.wait_window()
        
        return result

    def on_scan_complete(self, departments_info):
        """Обработчик завершения сканирования"""
        self.scan_data = departments_info
        
        if departments_info:
            total_departments = len(departments_info)
            total_files = sum(departments_info.values())
            
            self.add_info("")
            self.add_info("АНАЛИЗ ЗАВЕРШЕН", "success")
            self.add_info("")
            
            # Показываем выбранные подразделения
            self.add_info("Выбранные подразделения:", "success")
            for dept in self.selected_departments:
                self.add_info(f"  • {dept['name']}: {dept['files_count']} файлов")
            
            self.add_info("")
            self.add_info("Статистика обработки:", "success")
            self.add_info(f"  • Подразделений: {total_departments}")
            self.add_info(f"  • Файлов сотрудников: {total_files}")
            
            # Проверка шаблона
            template_key = "block_report_template" if self.tab_type == "departments" else "general_report_template"
            template_path = Path(getattr(self.config, template_key))
            template_name = "отчета по подразделениям" if self.tab_type == "departments" else "общего отчета"
            
            if template_path.exists():
                self.add_info(f"  • Шаблон {template_name}: найден")
                can_proceed = True
            else:
                self.add_info(f"  • Шаблон {template_name}: НЕ НАЙДЕН", "error")
                self.add_info(f"    Файл: {template_path}", "error")
                can_proceed = False
            
            # Расчет времени (0.3 сек на файл)
            estimated_time = total_files * 0.3
            self.add_info(f"  • Ожидаемое время: {estimated_time:.1f} сек")
            
            self.add_info("")
            if can_proceed:
                if self.tab_type == "departments":
                    self.add_info("Будет создан отчет в каждом выбранном подразделении", "success")
                    self.add_info("Нажмите 'Создать отчеты по подразделениям' для начала", "success")
                else:
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    self.add_info(f"Будет создан файл: ОБЩИЙ_ОТЧЕТ_{timestamp}.xlsx", "success")
                    self.add_info("Нажмите 'Создать общий отчет' для начала", "success")
                
                # При повторном анализе отмечаем что была активность
                if hasattr(self, 'path_reselected'):
                    self.path_reselected = True
                
                self.action_btn.config(state=tk.NORMAL)
            else:
                self.add_info("Исправьте проблему с шаблоном для продолжения", "error")
                self.action_btn.config(state=tk.DISABLED)
        else:
            self.add_info("В выбранной папке не найдено подразделений с файлами сотрудников", "warning")
            self.action_btn.config(state=tk.DISABLED)
            
    def on_scan_error(self, error_message):
        """Обработчик ошибки сканирования"""
        self.add_info(f"Ошибка сканирования: {error_message}", "error")
        messagebox.showerror("Ошибка сканирования", error_message)
    
    def start_processing(self):
        """Начало обработки"""
        if not self.scan_data:
            messagebox.showwarning("Предупреждение", "Сначала выполните сканирование")
            return
        
        self.is_processing = True
        self.action_btn.config(state=tk.DISABLED)
        self.show_progress_view()
        
        def processing_thread():
            try:
                if self.tab_type == "departments":
                    # Обновление отчетов по подразделениям
                    operation_log = self.processor.update_block_reports(
                        self.selected_departments,
                        self.on_progress_update
                    )
                else:
                    # Создание общего отчета
                    operation_log = self.processor.create_general_report(
                        self.selected_departments,
                        self.target_path,
                        self.on_progress_update
                    )
                
                self.frame.after(0, self.on_processing_complete, operation_log)
            except Exception as e:
                self.frame.after(0, self.on_processing_error, str(e))
        
        threading.Thread(target=processing_thread, daemon=True).start()

    def on_progress_update(self, progress):
        """Обработчик обновления прогресса"""
        def update_ui():
            # ИСПРАВЛЕНИЕ: Проверяем что окно еще существует
            try:
                if not self.frame.winfo_exists():
                    return
            except tk.TclError:
                return
            
            # Общий процент
            if self.tab_type == "departments":
                if progress.total_files > 0:
                    overall_percent = (progress.processed_files / progress.total_files) * 100
                    self.overall_progress_label.config(text=f"Общий прогресс: {overall_percent:.1f}%")
            else:
                if progress.total_blocks > 0:
                    overall_percent = (progress.processed_blocks / progress.total_blocks) * 100
                    self.overall_progress_label.config(text=f"Общий прогресс: {overall_percent:.1f}%")
            
            # Время
            elapsed = (datetime.now() - progress.start_time).total_seconds() if progress.start_time else 0
            
            if self.tab_type == "departments":
                if progress.processed_files > 0 and progress.total_files > 0:
                    speed = progress.processed_files / elapsed if elapsed > 0 else 0
                    remaining_files = progress.total_files - progress.processed_files
                    remaining_time = remaining_files / speed if speed > 0 else 0
                    self.time_label.config(text=f"Прошло: {elapsed:.0f} сек, Осталось: {remaining_time:.0f} сек")
                else:
                    self.time_label.config(text=f"Прошло: {elapsed:.0f} сек")
            else:
                if progress.processed_blocks > 0 and progress.total_blocks > 0:
                    speed = progress.processed_blocks / elapsed if elapsed > 0 else 0
                    remaining_blocks = progress.total_blocks - progress.processed_blocks
                    remaining_time = remaining_blocks / speed if speed > 0 else 0
                    self.time_label.config(text=f"Прошло: {elapsed:.0f} сек, Осталось: {remaining_time:.0f} сек")
                else:
                    self.time_label.config(text=f"Прошло: {elapsed:.0f} сек")
            
            # Верхний прогресс-бар (отделы)
            if progress.total_blocks > 0:
                dept_percent = (progress.processed_blocks / progress.total_blocks) * 100
                self.dept_progress_bar['value'] = dept_percent
                self.dept_detail_label.config(
                    text=f"Отдел {progress.processed_blocks}/{progress.total_blocks}: {progress.current_block or 'Готовится...'}"
                )
            
            # ИСПРАВЛЕННЫЙ НИЖНИЙ ПРОГРЕСС-БАР
            if self.tab_type == "departments":
                # ДЛЯ ОТЧЕТОВ ПО ПОДРАЗДЕЛЕНИЯМ - реальные файлы в текущем отделе
                if hasattr(self, 'selected_departments') and self.selected_departments:
                    current_dept_index = progress.processed_blocks
                    
                    if 0 <= current_dept_index < len(self.selected_departments):
                        current_dept = self.selected_departments[current_dept_index]
                        files_in_dept = current_dept['files_count']
                        
                        if files_in_dept > 0:
                            # ИСПРАВЛЕНИЕ: Правильный расчет файлов в текущем отделе
                            files_before_current = sum(
                                self.selected_departments[i]['files_count'] 
                                for i in range(current_dept_index)
                            )
                            
                            # Файлы обработанные в текущем отделе
                            files_in_current = max(0, progress.processed_files - files_before_current)
                            files_in_current = min(files_in_current, files_in_dept)
                            
                            files_percent = (files_in_current / files_in_dept) * 100
                            self.files_progress_bar['value'] = files_percent
                            self.files_detail_label.config(
                                text=f"Файл {files_in_current}/{files_in_dept} в отделе"
                            )
                        else:
                            self.files_progress_bar['value'] = 0
                            self.files_detail_label.config(text="Нет файлов в отделе")
                    else:
                        self.files_progress_bar['value'] = 0
                        self.files_detail_label.config(text="Инициализация...")
                else:
                    self.files_progress_bar['value'] = 0
                    self.files_detail_label.config(text="Подготовка...")
            else:
                # ДЛЯ ОБЩЕГО ОТЧЕТА - эмуляция обработки каждого отдела
                if progress.total_blocks > 0:
                    avg_time_per_block = 2.0  # секунд на блок (как в processor.py)
                    
                    # ИСПРАВЛЕНИЕ: Определяем текущий блок корректно
                    current_block_index = progress.processed_blocks
                    
                    if current_block_index < progress.total_blocks:
                        # Обрабатываем текущий блок
                        time_spent_on_completed_blocks = current_block_index * avg_time_per_block
                        time_in_current_block = max(0, elapsed - time_spent_on_completed_blocks)
                        
                        # Прогресс в текущем блоке (от 0 до 100%)
                        block_progress = min(100, (time_in_current_block / avg_time_per_block) * 100)
                        
                        self.files_progress_bar['value'] = block_progress
                        
                        # Название текущего блока
                        if hasattr(self, 'selected_departments') and self.selected_departments:
                            if current_block_index < len(self.selected_departments):
                                dept_name = self.selected_departments[current_block_index]['name']
                            else:
                                dept_name = progress.current_block or f"Отдел {current_block_index + 1}"
                        else:
                            dept_name = progress.current_block or f"Отдел {current_block_index + 1}"
                        
                        self.files_detail_label.config(text=f"Обработка: {dept_name} ({block_progress:.0f}%)")
                    else:
                        # Все блоки завершены
                        self.files_progress_bar['value'] = 100
                        self.files_detail_label.config(text="Завершение...")
                else:
                    self.files_progress_bar['value'] = 0
                    self.files_detail_label.config(text="Подготовка...")
        
        # ИСПРАВЛЕНИЕ: Проверяем что фрейм еще существует перед обновлением
        try:
            if self.frame.winfo_exists():
                self.frame.after(0, update_ui)
        except tk.TclError:
            # Окно уже закрыто, игнорируем
            pass

    def show_progress_view(self):
        """Показать прогресс"""
        self.info_frame.grid_remove()
        self.progress_frame.grid(row=1, column=0, columnspan=3, pady=(0, 15), sticky=(tk.W, tk.E, tk.N, tk.S))
    
    def show_info_view(self):
        """Показать информацию"""
        self.progress_frame.grid_remove()
        self.info_frame.grid(row=1, column=0, columnspan=3, pady=(0, 15), sticky=(tk.W, tk.E, tk.N, tk.S))

    def on_processing_complete(self, operation_log):
        """Завершение обработки"""
        # ИСПРАВЛЕНИЕ: Проверяем что окно еще существует
        try:
            if not self.frame.winfo_exists():
                return
        except tk.TclError:
            return
        
        self.is_processing = False
        
        if operation_log.status == ProcessingStatus.SUCCESS:
            self.add_info_to_existing("")
            self.add_info_to_existing("=" * 50)
            self.add_info_to_existing("ОТЧЕТЫ УСПЕШНО СОЗДАНЫ!", "success")
            self.add_info_to_existing(f"Время: {operation_log.duration:.1f} сек")
            self.add_info_to_existing("=" * 50)
            
            for entry in operation_log.entries:
                if entry.level == "INFO":
                    self.add_info_to_existing(f"ИТОГ: {entry.message}", "success")
        else:
            self.add_info_to_existing("")
            self.add_info_to_existing("ОШИБКА СОЗДАНИЯ ОТЧЕТОВ!", "error")
            for entry in operation_log.entries:
                if entry.level == "ERROR":
                    self.add_info_to_existing(f"ОШИБКА: {entry.message}", "error")
            
            # Показываем messagebox с ошибкой
            messagebox.showerror("Ошибка создания отчетов", "Создание отчетов завершено с ошибками. См. подробности в окне.")
        
        self.show_info_view()
        
        # ИСПРАВЛЕНИЕ: ВСЕГДА показываем "Закрыть" после завершения
        self.action_btn.config(text="Закрыть", command=self.close_window, state=tk.NORMAL)


    def on_processing_error(self, error_message):
        """Ошибка обработки"""
        self.is_processing = False
        self.add_info(f"Критическая ошибка: {error_message}", "error")
        messagebox.showerror("Критическая ошибка", error_message)
        self.show_info_view()
        self.action_btn.config(text="Закрыть", command=self.close_window, state=tk.NORMAL)
    
    def close_window(self):
        """Закрытие окна"""
        # Будет реализовано в главном классе
        pass
    
    def add_info_to_existing(self, message: str, level: str = "info"):
        """Добавляет информацию без временной метки"""
        # ИСПРАВЛЕНИЕ: Проверяем что виджет еще существует
        try:
            if not self.info_text.winfo_exists():
                return
        except tk.TclError:
            return
        
        if level in ["success", "error", "warning"]:
            colors = {"warning": "#FF8C00", "error": "red", "success": "green"}
            color = colors[level]
            font_style = ("TkDefaultFont", 9, "bold")
        else:
            color = "black"
            font_style = ("TkDefaultFont", 9)
        
        if message.strip():
            self.info_text.insert(tk.END, f"{message}\n")
        else:
            self.info_text.insert(tk.END, "\n")
        
        if level in ["success", "error", "warning"]:
            start_line = self.info_text.index(tk.END + "-2l linestart")
            end_line = self.info_text.index(tk.END + "-1l lineend")
            tag_name = f"color_{level}_no_time"
            self.info_text.tag_add(tag_name, start_line, end_line)
            self.info_text.tag_config(tag_name, foreground=color, font=font_style)
        
        self.info_text.see(tk.END)

    def add_info_to_existing(self, message: str, level: str = "info"):
        """Добавляет информацию без временной метки"""
        if level in ["success", "error", "warning"]:
            colors = {"warning": "#FF8C00", "error": "red", "success": "green"}
            color = colors[level]
            font_style = ("TkDefaultFont", 9, "bold")
        else:
            color = "black"
            font_style = ("TkDefaultFont", 9)
        
        if message.strip():
            self.info_text.insert(tk.END, f"{message}\n")
        else:
            self.info_text.insert(tk.END, "\n")
        
        if level in ["success", "error", "warning"]:
            start_line = self.info_text.index(tk.END + "-2l linestart")
            end_line = self.info_text.index(tk.END + "-1l lineend")
            tag_name = f"color_{level}_no_time"
            self.info_text.tag_add(tag_name, start_line, end_line)
            self.info_text.tag_config(tag_name, foreground=color, font=font_style)
        
        self.info_text.see(tk.END)


class ReportsWindow:
    """Окно для работы с отчетами по отпускам"""
    
    def __init__(self, parent: tk.Tk, config: Config, main_window):
        self.parent = parent
        self.config = config
        self.main_window = main_window
        self.logger = logging.getLogger(__name__)
        self.processor = VacationProcessor(config)
        
        self.window = None
        self.dept_tab = None
        self.general_tab = None
        
        self.setup_ui()
    

    
    def setup_ui(self):
        """Настройка пользовательского интерфейса"""
        self.window = tk.Toplevel(self.parent)
        self.window.title("Работа с отчетами")
        self.window.geometry("750x600")
        self.window.resizable(True, True)
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        main_frame = ttk.Frame(self.window, padding="15")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        self.window.columnconfigure(0, weight=1)
        self.window.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(0, weight=1)
        
        # Notebook с вкладками
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Создаем вкладки
        dept_frame = ttk.Frame(self.notebook, padding="15")
        general_frame = ttk.Frame(self.notebook, padding="15")
        
        self.notebook.add(dept_frame, text="По подразделениям")
        self.notebook.add(general_frame, text="Общий")
        
        # Создаем экземпляры вкладок
        self.dept_tab = ReportTab(dept_frame, self.config, self.processor, "departments")
        self.general_tab = ReportTab(general_frame, self.config, self.processor, "general")
        
        # Привязываем закрытие окна
        self.dept_tab.close_window = self.on_closing
        self.general_tab.close_window = self.on_closing
    
    def show(self):
        """Показывает окно"""
        if self.window:
            self.window.deiconify()
            self.window.lift()
            self.window.focus()
    
    def on_closing(self):
        """Обработчик закрытия окна"""
        if (self.dept_tab and self.dept_tab.is_processing) or (self.general_tab and self.general_tab.is_processing):
            result = messagebox.askyesno("Подтверждение", "Идет процесс обработки. Действительно закрыть окно?")
            if not result:
                return
        
        self.window.destroy()
        if self.main_window:
            self.main_window.on_window_closed("reports")



=============================================
FILE: D:\Users\chernousov-am\vp on pt\tests\test3\Блок банковских технологий\create_report.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Создание отчета по блоку - Автономный скрипт
Использует файлы сотрудников в текущей папке для создания отчета по подразделению
"""

import os
import sys
import time
import shutil
from pathlib import Path
from datetime import datetime, date
from typing import List, Optional, Dict
import re

try:
    import openpyxl
    from openpyxl.styles import PatternFill, Border, Side
    from openpyxl.utils import get_column_letter
except ImportError:
    print("ОШИБКА: Не установлена библиотека openpyxl")
    print("Установите: pip install openpyxl")
    input("Нажмите Enter для выхода...")
    sys.exit(1)


class Employee:
    """Простая модель сотрудника"""
    def __init__(self):
        self.full_name = ""
        self.tab_number = ""
        self.position = ""
        self.department1 = ""
        self.department2 = ""
        self.department3 = ""
        self.department4 = ""


class VacationPeriod:
    """Период отпуска"""
    def __init__(self, start_date: date, end_date: date, days: int = 0):
        self.start_date = start_date
        self.end_date = end_date
        self.days = days if days > 0 else (end_date - start_date).days + 1


class VacationInfo:
    """Информация об отпусках сотрудника"""
    def __init__(self, employee: Employee, periods: List[VacationPeriod] = None):
        self.employee = employee
        self.periods = periods or []
        self.total_days = sum(period.days for period in self.periods)
        self.periods_count = len(self.periods)
        self.has_long_period = any(period.days >= 14 for period in self.periods)
        self.validation_errors = []
        
        # Определяем статус
        if not self.periods:
            self.status = "Не заполнено"
        elif self.validation_errors:
            self.status = "Ошибка"
        elif self.total_days >= 28 and self.has_long_period:
            self.status = "Ок"
        else:
            self.status = "Частично"


class BlockReportCreator:
    """Создатель отчетов по блокам"""
    
    # Константы для 2026 года
    DAYS_IN_MONTH_2026 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    MONTH_NAMES = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 
                   'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']
    
    def __init__(self):
        self.template_path = r"M:\Подразделения\АУП\Стажерская программа\Отпуск Р7\templates\block_report_template.xlsx"
        
    def validate_template(self) -> bool:
        """Проверяет наличие шаблона"""
        if not Path(self.template_path).exists():
            print(f"ОШИБКА: Шаблон не найден по пути: {self.template_path}")
            return False
        print(f"✓ Шаблон найден")
        return True
    
    def scan_employee_files(self, directory: str) -> List[str]:
        """Сканирует файлы сотрудников в папке"""
        employee_files = []
        directory_path = Path(directory)
        
        print(f"Сканирование папки: {directory_path.absolute()}")
        
        for file_path in directory_path.iterdir():
            if not file_path.is_file() or file_path.suffix.lower() != '.xlsx':
                continue
            
            filename = file_path.name
            
            # Исключаем отчеты и системные файлы
            if (filename.startswith('~') or 
                filename.startswith('!') or
                filename.startswith('Отчет') or
                filename.startswith('отчет') or
                filename.startswith('ОБЩИЙ') or
                'report' in filename.lower()):
                continue
            
            employee_files.append(str(file_path))
        
        print(f"✓ Найдено файлов сотрудников: {len(employee_files)}")
        return employee_files
    
    def parse_date(self, date_value) -> Optional[date]:
        """Парсит дату из различных форматов"""
        if not date_value:
            return None
        
        # Если уже date или datetime
        if isinstance(date_value, date):
            return date_value
        if isinstance(date_value, datetime):
            return date_value.date()
        
        # Если строка
        date_str = str(date_value).strip()
        if not date_str:
            return None
        
        # Попробуем различные форматы
        formats = ["%d.%m.%Y", "%d.%m.%y", "%Y-%m-%d", "%d/%m/%Y", "%d/%m/%y"]
        
        for fmt in formats:
            try:
                parsed_date = datetime.strptime(date_str, fmt).date()
                return parsed_date
            except ValueError:
                continue
        
        return None
    
    def get_cell_value(self, worksheet, cell_address: str):
        """Безопасно получает значение ячейки"""
        try:
            cell = worksheet[cell_address]
            return cell.value
        except Exception:
            return None
    
    def read_vacation_info_from_file(self, file_path: str) -> Optional[VacationInfo]:
        """Читает информацию об отпусках из файла сотрудника"""
        try:
            workbook = openpyxl.load_workbook(file_path, data_only=True)
            worksheet = workbook.active
            
            # Читаем базовую информацию о сотруднике
            employee = Employee()
            
            # Ищем первую заполненную строку для получения базовой информации (строки 9-23)
            for row in range(9, 24):
                tab_number = self.get_cell_value(worksheet, f"B{row}")
                full_name = self.get_cell_value(worksheet, f"C{row}")
                position = self.get_cell_value(worksheet, f"D{row}")
                
                if tab_number and full_name:
                    employee.tab_number = str(tab_number).strip()
                    employee.full_name = str(full_name).strip()
                    if position:
                        employee.position = str(position).strip()
                    break
            
            # Читаем подразделения из шапки файла (C2:C5)
            employee.department1 = str(self.get_cell_value(worksheet, "C2") or "").strip()
            employee.department2 = str(self.get_cell_value(worksheet, "C3") or "").strip()
            employee.department3 = str(self.get_cell_value(worksheet, "C4") or "").strip()
            employee.department4 = str(self.get_cell_value(worksheet, "C5") or "").strip()
            
            # Читаем периоды отпусков из строк 9-23
            periods = []
            
            for row in range(9, 24):
                start_date_value = self.get_cell_value(worksheet, f"E{row}")
                end_date_value = self.get_cell_value(worksheet, f"F{row}")
                days_value = self.get_cell_value(worksheet, f"G{row}")
                
                if not start_date_value or not end_date_value:
                    continue
                
                try:
                    # Парсим даты
                    start_date = self.parse_date(start_date_value)
                    end_date = self.parse_date(end_date_value)
                    
                    if not start_date or not end_date:
                        continue
                    
                    # Парсим количество дней
                    days = 0
                    if days_value:
                        try:
                            days = int(days_value)
                        except (ValueError, TypeError):
                            days = (end_date - start_date).days + 1
                    else:
                        days = (end_date - start_date).days + 1
                    
                    period = VacationPeriod(start_date=start_date, end_date=end_date, days=days)
                    periods.append(period)
                    
                except Exception as e:
                    print(f"ПРЕДУПРЕЖДЕНИЕ: Ошибка обработки периода в строке {row}: {e}")
                    continue
            
            # Читаем результаты валидации
            validation_h2 = str(self.get_cell_value(worksheet, "H2") or "").strip()
            validation_i2 = str(self.get_cell_value(worksheet, "I2") or "").strip()
            validation_j2 = self.get_cell_value(worksheet, "J2") or 0
            
            # Создаем VacationInfo
            vacation_info = VacationInfo(employee=employee, periods=periods)
            
            # Определяем статус на основе валидаций
            if "ОШИБКА" in validation_h2:
                vacation_info.validation_errors.append(validation_h2)
            
            if "ОШИБКА" in validation_i2:
                vacation_info.validation_errors.append(validation_i2)
            
            try:
                total_days = int(validation_j2) if validation_j2 else 0
                if total_days < 28:
                    vacation_info.validation_errors.append(f"ОШИБКА: Недостаточно дней отпуска. Запланировано {total_days} дней, требуется минимум 28.")
            except (ValueError, TypeError):
                vacation_info.validation_errors.append("ОШИБКА: Не удалось определить общее количество дней отпуска.")
            
            # Обновляем статус
            if not vacation_info.validation_errors:
                vacation_info.status = "Ок"
            else:
                vacation_info.status = "Ошибка"
            
            workbook.close()
            return vacation_info
            
        except Exception as e:
            print(f"ОШИБКА: Не удалось прочитать файл {file_path}: {e}")
            return None
    
    def get_calendar_column(self, target_date: date, start_col: int) -> Optional[int]:
        """Вычисляет номер столбца для конкретной даты в календарной матрице"""
        if target_date.year != 2026:
            return None
        
        col_offset = 0
        # Считаем смещение по месяцам
        for month in range(1, target_date.month):
            col_offset += self.DAYS_IN_MONTH_2026[month - 1]
        
        # Добавляем день месяца
        col_offset += target_date.day - 1
        
        return start_col + col_offset
    
    def fill_calendar_matrix(self, worksheet, vacation_infos: List[VacationInfo]):
        """Заполняет календарную матрицу на листе Report"""
        try:
            start_col = 12  # Столбец L
            
            # Заполняем месяца в строке 7
            col_offset = 0
            for month_idx, month_name in enumerate(self.MONTH_NAMES):
                month_col = start_col + col_offset
                worksheet.cell(row=7, column=month_col, value=month_name)
                
                # Заполняем дни месяца в строке 8
                days_in_month = self.DAYS_IN_MONTH_2026[month_idx]
                for day in range(1, days_in_month + 1):
                    day_col = start_col + col_offset + day - 1
                    worksheet.cell(row=8, column=day_col, value=day)
                
                col_offset += days_in_month
            
            # Заполняем отпуска для каждого сотрудника
            for emp_idx, vacation_info in enumerate(vacation_infos):
                emp_row = emp_idx + 9  # Строка сотрудника
                
                for period in vacation_info.periods:
                    # Заполняем дни отпуска единицами
                    current_date = period.start_date
                    while current_date <= period.end_date:
                        if current_date.year == 2026:  # Только для 2026 года
                            day_col = self.get_calendar_column(current_date, start_col)
                            if day_col:
                                worksheet.cell(row=emp_row, column=day_col, value=1)
                        
                        # Переход к следующему дню
                        from datetime import timedelta
                        current_date = current_date + timedelta(days=1)
                        
                        if current_date > period.end_date:
                            break
                            
        except Exception as e:
            print(f"ОШИБКА: Ошибка заполнения календарной матрицы: {e}")
    
    def create_block_report(self, block_name: str, vacation_infos: List[VacationInfo], output_path: str) -> bool:
        """Создает отчет по блоку с календарной матрицей"""
        try:
            # Копируем шаблон
            shutil.copy2(self.template_path, output_path)
            
            # Открываем файл для заполнения
            workbook = openpyxl.load_workbook(output_path)
            
            # Заполняем лист Report
            self.fill_report_sheet(workbook, block_name, vacation_infos)
            
            # Заполняем лист Print
            self.fill_print_sheet(workbook, block_name, vacation_infos)
            
            workbook.save(output_path)
            workbook.close()
            
            print(f"✓ Отчет создан: {output_path}")
            return True
            
        except Exception as e:
            print(f"ОШИБКА: Ошибка создания отчета по блоку {block_name}: {e}")
            return False
    
    def fill_report_sheet(self, workbook, block_name: str, vacation_infos: List[VacationInfo]):
        """Заполняет лист Report"""
        if 'Report' not in workbook.sheetnames:
            print("ОШИБКА: Лист 'Report' не найден в шаблоне")
            return
        
        worksheet = workbook['Report']
        current_time = datetime.now()
        
        # Шапка A3:A6
        worksheet["A3"] = block_name
        worksheet["A4"] = f"Дата обновления: {current_time.strftime('%d.%m.%Y %H:%M')}"
        worksheet["A5"] = f"Количество сотрудников: {len(vacation_infos)}"
        
        # Подсчет завершивших планирование
        completed = sum(1 for vi in vacation_infos if vi.status == "Ок")
        percentage = (completed / len(vacation_infos) * 100) if vacation_infos else 0
        worksheet["A6"] = f"Закончили планирование: {completed} ({percentage:.0f}%)"
        
        # Заполняем таблицу сотрудников (начиная с строки 9)
        for i, vacation_info in enumerate(vacation_infos):
            row = i + 9
            emp = vacation_info.employee
            
            worksheet[f"A{row}"] = i + 1  # №
            worksheet[f"B{row}"] = emp.full_name  # ФИО
            worksheet[f"C{row}"] = emp.tab_number  # Таб. Номер
            worksheet[f"D{row}"] = emp.position  # Должность
            worksheet[f"E{row}"] = emp.department1  # Подразделение 1
            worksheet[f"F{row}"] = emp.department2  # Подразделение 2
            worksheet[f"G{row}"] = emp.department3  # Подразделение 3
            worksheet[f"H{row}"] = emp.department4  # Подразделение 4
            
            # Статус планирования
            if vacation_info.status == "Ок":
                worksheet[f"I{row}"] = "Ок"
            else:
                errors = vacation_info.validation_errors
                worksheet[f"I{row}"] = "\n".join(errors) if errors else "Ошибка"
            
            worksheet[f"J{row}"] = vacation_info.total_days  # Итого дней
            worksheet[f"K{row}"] = vacation_info.periods_count  # Кол-во периодов
            
            # Добавляем границы
            thin_border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )

            # Применить границы к диапазону строки (столбцы A-K + календарь)
            for col in range(1, 378):  # A до столбца календаря
                worksheet.cell(row=row, column=col).border = thin_border
        
        # Заполняем календарную матрицу
        self.fill_calendar_matrix(worksheet, vacation_infos)
    
    def fill_print_sheet(self, workbook, block_name: str, vacation_infos: List[VacationInfo]):
        """Заполняет лист Print в нормализованном виде"""
        if 'Print' not in workbook.sheetnames:
            print("ОШИБКА: Лист 'Print' не найден в шаблоне")
            return
        
        worksheet = workbook['Print']
        
        # D4 - название блока
        worksheet["D4"] = block_name
        
        # Нормализуем данные - каждый период отпуска = отдельная строка
        normalized_data = []
        for vacation_info in vacation_infos:
            emp = vacation_info.employee
            
            if not vacation_info.periods:
                # Если нет периодов, добавляем пустую строку
                normalized_data.append({
                    'employee': emp,
                    'period_num': 0,
                    'start_date': None,
                    'end_date': None,
                    'days': 0
                })
            else:
                # Добавляем строку для каждого периода
                for period_idx, period in enumerate(vacation_info.periods, 1):
                    normalized_data.append({
                        'employee': emp,
                        'period_num': period_idx,
                        'start_date': period.start_date,
                        'end_date': period.end_date,
                        'days': period.days
                    })
        
        # Заполняем данные с учетом разбивки по страницам
        current_row = 9  # Начинаем с 9 строки
        records_on_page = 0
        max_records_first_page = 14
        max_records_other_pages = 18
        is_first_page = True
        
        for record_idx, record in enumerate(normalized_data):
            # Проверяем нужность новой страницы
            max_records = max_records_first_page if is_first_page else max_records_other_pages
            
            if records_on_page >= max_records:
                # Добавляем заголовки на новой странице
                current_row += 1  # Пропускаем строку
                self.add_print_headers(worksheet, current_row)
                current_row += 1
                records_on_page = 0
                is_first_page = False
            
            # Заполняем строку данных
            emp = record['employee']
            
            worksheet[f"A{current_row}"] = record_idx + 1  # № п/п
            worksheet[f"B{current_row}"] = emp.tab_number  # Табельный номер
            worksheet[f"C{current_row}"] = emp.full_name  # ФИО
            worksheet[f"D{current_row}"] = emp.position  # Должность
            
            if record['start_date']:
                worksheet[f"E{current_row}"] = record['start_date'].strftime('%d.%m.%Y')  # Дата начала
                worksheet[f"F{current_row}"] = record['end_date'].strftime('%d.%m.%Y')  # Дата окончания
                worksheet[f"G{current_row}"] = record['days']  # Продолжительность
            
            current_row += 1
            records_on_page += 1
    
    def add_print_headers(self, worksheet, row: int):
        """Добавляет заголовки таблицы для печати"""
        headers = [
            "№ п/п", "Табельный номер", "ФИО", "Должность",
            "Дата начала отпуска", "Дата окончания отпуска",
            "Продолжительность (календарных дней)",
            "Подпись работника", "Дата ознакомления работника", "Примечание"
        ]
        
        for col_idx, header in enumerate(headers, 1):
            worksheet.cell(row=row, column=col_idx, value=header)


def main():
    """Главная функция скрипта"""
    print("=" * 60)
    print("  СОЗДАНИЕ ОТЧЕТА ПО БЛОКУ")
    print("  Автономный скрипт для создания отчетов по подразделениям")
    print("=" * 60)
    print()
    
    creator = BlockReportCreator()
    
    # 1. Проверяем шаблон
    print("1. Проверка шаблона...")
    if not creator.validate_template():
        input("Нажмите Enter для выхода...")
        return
    
    # 2. Определяем текущую папку
    current_dir = os.getcwd()
    print(f"2. Текущая папка: {current_dir}")
    
    # 3. Сканируем файлы сотрудников
    print("3. Поиск файлов сотрудников...")
    employee_files = creator.scan_employee_files(current_dir)
    
    if not employee_files:
        print("ОШИБКА: В текущей папке не найдено файлов сотрудников (.xlsx)")
        input("Нажмите Enter для выхода...")
        return
    
    # 4. Читаем данные из файлов
    print("4. Чтение данных из файлов...")
    vacation_infos = []
    invalid_files = []
    
    for i, file_path in enumerate(employee_files, 1):
        print(f"   Обработка {i}/{len(employee_files)}: {Path(file_path).name}")
        vacation_info = creator.read_vacation_info_from_file(file_path)
        
        if vacation_info:
            vacation_infos.append(vacation_info)
        else:
            invalid_files.append(Path(file_path).name)
    
    if not vacation_infos:
        print("ОШИБКА: Не удалось прочитать ни одного файла сотрудника")
        input("Нажмите Enter для выхода...")
        return
    
    print(f"✓ Успешно обработано файлов: {len(vacation_infos)} из {len(employee_files)}")
    
    if invalid_files:
        print(f"Сотрудников с неверно заполненным файлом: {len(invalid_files)}")
        for invalid_file in invalid_files:
            print(f"   • {invalid_file}")
    
    # 5. Определяем название блока из первого сотрудника
    block_name = vacation_infos[0].employee.department1 or "Неизвестное подразделение"
    print(f"5. Название блока: {block_name}")
    
    # 6. Создаем отчет
    print("6. Создание отчета...")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = f"Отчет по блоку_{block_name}_{timestamp}.xlsx"
    
    # Очищаем имя файла от недопустимых символов
    invalid_chars = r'[\\/:*?"<>|]'
    output_filename = re.sub(invalid_chars, '_', output_filename)
    output_path = Path(current_dir) / output_filename
    
    success = creator.create_block_report(block_name, vacation_infos, str(output_path))
    
    if success:
        print()
        print("=" * 60)
        print("  ОТЧЕТ УСПЕШНО СОЗДАН!")
        print("=" * 60)
        print(f"Файл: {output_filename}")
        print(f"Подразделение: {block_name}")
        print(f"Сотрудников: {len(vacation_infos)}")
        
        # Статистика по статусам с детализацией ошибок
        status_counts = {}
        error_types = {}
        
        for vi in vacation_infos:
            status = vi.status
            status_counts[status] = status_counts.get(status, 0) + 1
            
            # Детализация ошибок
            if vi.validation_errors:
                for error in vi.validation_errors:
                    if "Недостаточно дней отпуска" in error:
                        error_types["Недостаточно дней отпуска"] = error_types.get("Недостаточно дней отпуска", 0) + 1
                    elif "пересечение периодов" in error.lower():
                        error_types["Пересечение периодов"] = error_types.get("Пересечение периодов", 0) + 1
                    elif "Не удалось определить" in error:
                        error_types["Проблемы с подсчетом дней"] = error_types.get("Проблемы с подсчетом дней", 0) + 1
                    else:
                        error_types["Прочие ошибки"] = error_types.get("Прочие ошибки", 0) + 1
        
        print("Статистика планирования:")
        for status, count in status_counts.items():
            print(f"  {status}: {count}")
        
        if error_types:
            print("Типы ошибок:")
            for error_type, count in error_types.items():
                print(f"  {error_type}: {count}")
        
        print()
        print("Отчет создан в текущей папке.")
    else:
        print("ОШИБКА: Не удалось создать отчет")
    
    print()
    input("Нажмите Enter для выхода...")


if __name__ == "__main__":
    main()



=============================================
FILE: D:\Users\chernousov-am\vp on pt\tests\test3\Блок обеспечения и контроля качества выпуска изменений ПО\create_report.py
=============================================
Lines: 0

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Создание отчета по блоку - Автономный скрипт
Использует файлы сотрудников в текущей папке для создания отчета по подразделению
"""

import os
import sys
import time
import shutil
from pathlib import Path
from datetime import datetime, date
from typing import List, Optional, Dict
import re

try:
    import openpyxl
    from openpyxl.styles import PatternFill, Border, Side
    from openpyxl.utils import get_column_letter
except ImportError:
    print("ОШИБКА: Не установлена библиотека openpyxl")
    print("Установите: pip install openpyxl")
    input("Нажмите Enter для выхода...")
    sys.exit(1)


class Employee:
    """Простая модель сотрудника"""
    def __init__(self):
        self.full_name = ""
        self.tab_number = ""
        self.position = ""
        self.department1 = ""
        self.department2 = ""
        self.department3 = ""
        self.department4 = ""


class VacationPeriod:
    """Период отпуска"""
    def __init__(self, start_date: date, end_date: date, days: int = 0):
        self.start_date = start_date
        self.end_date = end_date
        self.days = days if days > 0 else (end_date - start_date).days + 1


class VacationInfo:
    """Информация об отпусках сотрудника"""
    def __init__(self, employee: Employee, periods: List[VacationPeriod] = None):
        self.employee = employee
        self.periods = periods or []
        self.total_days = sum(period.days for period in self.periods)
        self.periods_count = len(self.periods)
        self.has_long_period = any(period.days >= 14 for period in self.periods)
        self.validation_errors = []
        
        # Определяем статус
        if not self.periods:
            self.status = "Не заполнено"
        elif self.validation_errors:
            self.status = "Ошибка"
        elif self.total_days >= 28 and self.has_long_period:
            self.status = "Ок"
        else:
            self.status = "Частично"


class BlockReportCreator:
    """Создатель отчетов по блокам"""
    
    # Константы для 2026 года
    DAYS_IN_MONTH_2026 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    MONTH_NAMES = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 
                   'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']
    
    def __init__(self):
        self.template_path = r"M:\Подразделения\АУП\Стажерская программа\Отпуск Р7\templates\block_report_template.xlsx"
        
    def validate_template(self) -> bool:
        """Проверяет наличие шаблона"""
        if not Path(self.template_path).exists():
            print(f"ОШИБКА: Шаблон не найден по пути: {self.template_path}")
            return False
        print(f"✓ Шаблон найден")
        return True
    
    def scan_employee_files(self, directory: str) -> List[str]:
        """Сканирует файлы сотрудников в папке"""
        employee_files = []
        directory_path = Path(directory)
        
        print(f"Сканирование папки: {directory_path.absolute()}")
        
        for file_path in directory_path.iterdir():
            if not file_path.is_file() or file_path.suffix.lower() != '.xlsx':
                continue
            
            filename = file_path.name
            
            # Исключаем отчеты и системные файлы
            if (filename.startswith('~') or 
                filename.startswith('!') or
                filename.startswith('Отчет') or
                filename.startswith('отчет') or
                filename.startswith('ОБЩИЙ') or
                'report' in filename.lower()):
                continue
            
            employee_files.append(str(file_path))
        
        print(f"✓ Найдено файлов сотрудников: {len(employee_files)}")
        return employee_files
    
    def parse_date(self, date_value) -> Optional[date]:
        """Парсит дату из различных форматов"""
        if not date_value:
            return None
        
        # Если уже date или datetime
        if isinstance(date_value, date):
            return date_value
        if isinstance(date_value, datetime):
            return date_value.date()
        
        # Если строка
        date_str = str(date_value).strip()
        if not date_str:
            return None
        
        # Попробуем различные форматы
        formats = ["%d.%m.%Y", "%d.%m.%y", "%Y-%m-%d", "%d/%m/%Y", "%d/%m/%y"]
        
        for fmt in formats:
            try:
                parsed_date = datetime.strptime(date_str, fmt).date()
                return parsed_date
            except ValueError:
                continue
        
        return None
    
    def get_cell_value(self, worksheet, cell_address: str):
        """Безопасно получает значение ячейки"""
        try:
            cell = worksheet[cell_address]
            return cell.value
        except Exception:
            return None
    
    def read_vacation_info_from_file(self, file_path: str) -> Optional[VacationInfo]:
        """Читает информацию об отпусках из файла сотрудника"""
        try:
            workbook = openpyxl.load_workbook(file_path, data_only=True)
            worksheet = workbook.active
            
            # Читаем базовую информацию о сотруднике
            employee = Employee()
            
            # Ищем первую заполненную строку для получения базовой информации (строки 9-23)
            for row in range(9, 24):
                tab_number = self.get_cell_value(worksheet, f"B{row}")
                full_name = self.get_cell_value(worksheet, f"C{row}")
                position = self.get_cell_value(worksheet, f"D{row}")
                
                if tab_number and full_name:
                    employee.tab_number = str(tab_number).strip()
                    employee.full_name = str(full_name).strip()
                    if position:
                        employee.position = str(position).strip()
                    break
            
            # Читаем подразделения из шапки файла (C2:C5)
            employee.department1 = str(self.get_cell_value(worksheet, "C2") or "").strip()
            employee.department2 = str(self.get_cell_value(worksheet, "C3") or "").strip()
            employee.department3 = str(self.get_cell_value(worksheet, "C4") or "").strip()
            employee.department4 = str(self.get_cell_value(worksheet, "C5") or "").strip()
            
            # Читаем периоды отпусков из строк 9-23
            periods = []
            
            for row in range(9, 24):
                start_date_value = self.get_cell_value(worksheet, f"E{row}")
                end_date_value = self.get_cell_value(worksheet, f"F{row}")
                days_value = self.get_cell_value(worksheet, f"G{row}")
                
                if not start_date_value or not end_date_value:
                    continue
                
                try:
                    # Парсим даты
                    start_date = self.parse_date(start_date_value)
                    end_date = self.parse_date(end_date_value)
                    
                    if not start_date or not end_date:
                        continue
                    
                    # Парсим количество дней
                    days = 0
                    if days_value:
                        try:
                            days = int(days_value)
                        except (ValueError, TypeError):
                            days = (end_date - start_date).days + 1
                    else:
                        days = (end_date - start_date).days + 1
                    
                    period = VacationPeriod(start_date=start_date, end_date=end_date, days=days)
                    periods.append(period)
                    
                except Exception as e:
                    print(f"ПРЕДУПРЕЖДЕНИЕ: Ошибка обработки периода в строке {row}: {e}")
                    continue
            
            # Читаем результаты валидации
            validation_h2 = str(self.get_cell_value(worksheet, "H2") or "").strip()
            validation_i2 = str(self.get_cell_value(worksheet, "I2") or "").strip()
            validation_j2 = self.get_cell_value(worksheet, "J2") or 0
            
            # Создаем VacationInfo
            vacation_info = VacationInfo(employee=employee, periods=periods)
            
            # Определяем статус на основе валидаций
            if "ОШИБКА" in validation_h2:
                vacation_info.validation_errors.append(validation_h2)
            
            if "ОШИБКА" in validation_i2:
                vacation_info.validation_errors.append(validation_i2)
            
            try:
                total_days = int(validation_j2) if validation_j2 else 0
                if total_days < 28:
                    vacation_info.validation_errors.append(f"ОШИБКА: Недостаточно дней отпуска. Запланировано {total_days} дней, требуется минимум 28.")
            except (ValueError, TypeError):
                vacation_info.validation_errors.append("ОШИБКА: Не удалось определить общее количество дней отпуска.")
            
            # Обновляем статус
            if not vacation_info.validation_errors:
                vacation_info.status = "Ок"
            else:
                vacation_info.status = "Ошибка"
            
            workbook.close()
            return vacation_info
            
        except Exception as e:
            print(f"ОШИБКА: Не удалось прочитать файл {file_path}: {e}")
            return None
    
    def get_calendar_column(self, target_date: date, start_col: int) -> Optional[int]:
        """Вычисляет номер столбца для конкретной даты в календарной матрице"""
        if target_date.year != 2026:
            return None
        
        col_offset = 0
        # Считаем смещение по месяцам
        for month in range(1, target_date.month):
            col_offset += self.DAYS_IN_MONTH_2026[month - 1]
        
        # Добавляем день месяца
        col_offset += target_date.day - 1
        
        return start_col + col_offset
    
    def fill_calendar_matrix(self, worksheet, vacation_infos: List[VacationInfo]):
        """Заполняет календарную матрицу на листе Report"""
        try:
            start_col = 12  # Столбец L
            
            # Заполняем месяца в строке 7
            col_offset = 0
            for month_idx, month_name in enumerate(self.MONTH_NAMES):
                month_col = start_col + col_offset
                worksheet.cell(row=7, column=month_col, value=month_name)
                
                # Заполняем дни месяца в строке 8
                days_in_month = self.DAYS_IN_MONTH_2026[month_idx]
                for day in range(1, days_in_month + 1):
                    day_col = start_col + col_offset + day - 1
                    worksheet.cell(row=8, column=day_col, value=day)
                
                col_offset += days_in_month
            
            # Заполняем отпуска для каждого сотрудника
            for emp_idx, vacation_info in enumerate(vacation_infos):
                emp_row = emp_idx + 9  # Строка сотрудника
                
                for period in vacation_info.periods:
                    # Заполняем дни отпуска единицами
                    current_date = period.start_date
                    while current_date <= period.end_date:
                        if current_date.year == 2026:  # Только для 2026 года
                            day_col = self.get_calendar_column(current_date, start_col)
                            if day_col:
                                worksheet.cell(row=emp_row, column=day_col, value=1)
                        
                        # Переход к следующему дню
                        from datetime import timedelta
                        current_date = current_date + timedelta(days=1)
                        
                        if current_date > period.end_date:
                            break
                            
        except Exception as e:
            print(f"ОШИБКА: Ошибка заполнения календарной матрицы: {e}")
    
    def create_block_report(self, block_name: str, vacation_infos: List[VacationInfo], output_path: str) -> bool:
        """Создает отчет по блоку с календарной матрицей"""
        try:
            # Копируем шаблон
            shutil.copy2(self.template_path, output_path)
            
            # Открываем файл для заполнения
            workbook = openpyxl.load_workbook(output_path)
            
            # Заполняем лист Report
            self.fill_report_sheet(workbook, block_name, vacation_infos)
            
            # Заполняем лист Print
            self.fill_print_sheet(workbook, block_name, vacation_infos)
            
            workbook.save(output_path)
            workbook.close()
            
            print(f"✓ Отчет создан: {output_path}")
            return True
            
        except Exception as e:
            print(f"ОШИБКА: Ошибка создания отчета по блоку {block_name}: {e}")
            return False
    
    def fill_report_sheet(self, workbook, block_name: str, vacation_infos: List[VacationInfo]):
        """Заполняет лист Report"""
        if 'Report' not in workbook.sheetnames:
            print("ОШИБКА: Лист 'Report' не найден в шаблоне")
            return
        
        worksheet = workbook['Report']
        current_time = datetime.now()
        
        # Шапка A3:A6
        worksheet["A3"] = block_name
        worksheet["A4"] = f"Дата обновления: {current_time.strftime('%d.%m.%Y %H:%M')}"
        worksheet["A5"] = f"Количество сотрудников: {len(vacation_infos)}"
        
        # Подсчет завершивших планирование
        completed = sum(1 for vi in vacation_infos if vi.status == "Ок")
        percentage = (completed / len(vacation_infos) * 100) if vacation_infos else 0
        worksheet["A6"] = f"Закончили планирование: {completed} ({percentage:.0f}%)"
        
        # Заполняем таблицу сотрудников (начиная с строки 9)
        for i, vacation_info in enumerate(vacation_infos):
            row = i + 9
            emp = vacation_info.employee
            
            worksheet[f"A{row}"] = i + 1  # №
            worksheet[f"B{row}"] = emp.full_name  # ФИО
            worksheet[f"C{row}"] = emp.tab_number  # Таб. Номер
            worksheet[f"D{row}"] = emp.position  # Должность
            worksheet[f"E{row}"] = emp.department1  # Подразделение 1
            worksheet[f"F{row}"] = emp.department2  # Подразделение 2
            worksheet[f"G{row}"] = emp.department3  # Подразделение 3
            worksheet[f"H{row}"] = emp.department4  # Подразделение 4
            
            # Статус планирования
            if vacation_info.status == "Ок":
                worksheet[f"I{row}"] = "Ок"
            else:
                errors = vacation_info.validation_errors
                worksheet[f"I{row}"] = "\n".join(errors) if errors else "Ошибка"
            
            worksheet[f"J{row}"] = vacation_info.total_days  # Итого дней
            worksheet[f"K{row}"] = vacation_info.periods_count  # Кол-во периодов
            
            # Добавляем границы
            thin_border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )

            # Применить границы к диапазону строки (столбцы A-K + календарь)
            for col in range(1, 378):  # A до столбца календаря
                worksheet.cell(row=row, column=col).border = thin_border
        
        # Заполняем календарную матрицу
        self.fill_calendar_matrix(worksheet, vacation_infos)
    
    def fill_print_sheet(self, workbook, block_name: str, vacation_infos: List[VacationInfo]):
        """Заполняет лист Print в нормализованном виде"""
        if 'Print' not in workbook.sheetnames:
            print("ОШИБКА: Лист 'Print' не найден в шаблоне")
            return
        
        worksheet = workbook['Print']
        
        # D4 - название блока
        worksheet["D4"] = block_name
        
        # Нормализуем данные - каждый период отпуска = отдельная строка
        normalized_data = []
        for vacation_info in vacation_infos:
            emp = vacation_info.employee
            
            if not vacation_info.periods:
                # Если нет периодов, добавляем пустую строку
                normalized_data.append({
                    'employee': emp,
                    'period_num': 0,
                    'start_date': None,
                    'end_date': None,
                    'days': 0
                })
            else:
                # Добавляем строку для каждого периода
                for period_idx, period in enumerate(vacation_info.periods, 1):
                    normalized_data.append({
                        'employee': emp,
                        'period_num': period_idx,
                        'start_date': period.start_date,
                        'end_date': period.end_date,
                        'days': period.days
                    })
        
        # Заполняем данные с учетом разбивки по страницам
        current_row = 9  # Начинаем с 9 строки
        records_on_page = 0
        max_records_first_page = 14
        max_records_other_pages = 18
        is_first_page = True
        
        for record_idx, record in enumerate(normalized_data):
            # Проверяем нужность новой страницы
            max_records = max_records_first_page if is_first_page else max_records_other_pages
            
            if records_on_page >= max_records:
                # Добавляем заголовки на новой странице
                current_row += 1  # Пропускаем строку
                self.add_print_headers(worksheet, current_row)
                current_row += 1
                records_on_page = 0
                is_first_page = False
            
            # Заполняем строку данных
            emp = record['employee']
            
            worksheet[f"A{current_row}"] = record_idx + 1  # № п/п
            worksheet[f"B{current_row}"] = emp.tab_number  # Табельный номер
            worksheet[f"C{current_row}"] = emp.full_name  # ФИО
            worksheet[f"D{current_row}"] = emp.position  # Должность
            
            if record['start_date']:
                worksheet[f"E{current_row}"] = record['start_date'].strftime('%d.%m.%Y')  # Дата начала
                worksheet[f"F{current_row}"] = record['end_date'].strftime('%d.%m.%Y')  # Дата окончания
                worksheet[f"G{current_row}"] = record['days']  # Продолжительность
            
            current_row += 1
            records_on_page += 1
    
    def add_print_headers(self, worksheet, row: int):
        """Добавляет заголовки таблицы для печати"""
        headers = [
            "№ п/п", "Табельный номер", "ФИО", "Должность",
            "Дата начала отпуска", "Дата окончания отпуска",
            "Продолжительность (календарных дней)",
            "Подпись работника", "Дата ознакомления работника", "Примечание"
        ]
        
        for col_idx, header in enumerate(headers, 1):
            worksheet.cell(row=row, column=col_idx, value=header)


def main():
    """Главная функция скрипта"""
    print("=" * 60)
    print("  СОЗДАНИЕ ОТЧЕТА ПО БЛОКУ")
    print("  Автономный скрипт для создания отчетов по подразделениям")
    print("=" * 60)
    print()
    
    creator = BlockReportCreator()
    
    # 1. Проверяем шаблон
    print("1. Проверка шаблона...")
    if not creator.validate_template():
        input("Нажмите Enter для выхода...")
        return
    
    # 2. Определяем текущую папку
    current_dir = os.getcwd()
    print(f"2. Текущая папка: {current_dir}")
    
    # 3. Сканируем файлы сотрудников
    print("3. Поиск файлов сотрудников...")
    employee_files = creator.scan_employee_files(current_dir)
    
    if not employee_files:
        print("ОШИБКА: В текущей папке не найдено файлов сотрудников (.xlsx)")
        input("Нажмите Enter для выхода...")
        return
    
    # 4. Читаем данные из файлов
    print("4. Чтение данных из файлов...")
    vacation_infos = []
    invalid_files = []
    
    for i, file_path in enumerate(employee_files, 1):
        print(f"   Обработка {i}/{len(employee_files)}: {Path(file_path).name}")
        vacation_info = creator.read_vacation_info_from_file(file_path)
        
        if vacation_info:
            vacation_infos.append(vacation_info)
        else:
            invalid_files.append(Path(file_path).name)
    
    if not vacation_infos:
        print("ОШИБКА: Не удалось прочитать ни одного файла сотрудника")
        input("Нажмите Enter для выхода...")
        return
    
    print(f"✓ Успешно обработано файлов: {len(vacation_infos)} из {len(employee_files)}")
    
    if invalid_files:
        print(f"Сотрудников с неверно заполненным файлом: {len(invalid_files)}")
        for invalid_file in invalid_files:
            print(f"   • {invalid_file}")
    
    # 5. Определяем название блока из первого сотрудника
    block_name = vacation_infos[0].employee.department1 or "Неизвестное подразделение"
    print(f"5. Название блока: {block_name}")
    
    # 6. Создаем отчет
    print("6. Создание отчета...")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filename = f"Отчет по блоку_{block_name}_{timestamp}.xlsx"
    
    # Очищаем имя файла от недопустимых символов
    invalid_chars = r'[\\/:*?"<>|]'
    output_filename = re.sub(invalid_chars, '_', output_filename)
    output_path = Path(current_dir) / output_filename
    
    success = creator.create_block_report(block_name, vacation_infos, str(output_path))
    
    if success:
        print()
        print("=" * 60)
        print("  ОТЧЕТ УСПЕШНО СОЗДАН!")
        print("=" * 60)
        print(f"Файл: {output_filename}")
        print(f"Подразделение: {block_name}")
        print(f"Сотрудников: {len(vacation_infos)}")
        
        # Статистика по статусам с детализацией ошибок
        status_counts = {}
        error_types = {}
        
        for vi in vacation_infos:
            status = vi.status
            status_counts[status] = status_counts.get(status, 0) + 1
            
            # Детализация ошибок
            if vi.validation_errors:
                for error in vi.validation_errors:
                    if "Недостаточно дней отпуска" in error:
                        error_types["Недостаточно дней отпуска"] = error_types.get("Недостаточно дней отпуска", 0) + 1
                    elif "пересечение периодов" in error.lower():
                        error_types["Пересечение периодов"] = error_types.get("Пересечение периодов", 0) + 1
                    elif "Не удалось определить" in error:
                        error_types["Проблемы с подсчетом дней"] = error_types.get("Проблемы с подсчетом дней", 0) + 1
                    else:
                        error_types["Прочие ошибки"] = error_types.get("Прочие ошибки", 0) + 1
        
        print("Статистика планирования:")
        for status, count in status_counts.items():
            print(f"  {status}: {count}")
        
        if error_types:
            print("Типы ошибок:")
            for error_type, count in error_types.items():
                print(f"  {error_type}: {count}")
        
        print()
        print("Отчет создан в текущей папке.")
    else:
        print("ОШИБКА: Не удалось создать отчет")
    
    print()
    input("Нажмите Enter для выхода...")


if __name__ == "__main__":
    main()



=============================================
FILE: readme.md
=============================================
Lines: 0

# Vacation Tool - описание проекта

## Общее описание

**Vacation Tool** - десктопное приложение на Python с графическим интерфейсом (Tkinter) для автоматизации создания и управления файлами планирования отпусков сотрудников в организации.

## Бизнес-логика

### Основная задача
Массовое создание персональных Excel-форм для планирования отпусков сотрудников на основе данных штатного расписания с возможностью создания отчетов по заполнению.

### Бизнес-процесс
1. **HR-специалист** загружает файл Excel с данными сотрудников (штатное расписание)
2. **Система** валидирует данные и создает/дополняет структуру папок по подразделениям
3. **Для каждого сотрудника** создается персональный файл на основе шаблона
4. **Сотрудники** заполняют свои файлы, планируя отпуска
5. **Кураторы отделов** создают отчеты по подразделениям на основе заполненных файлов
6. **HR-специалист** создает общий отчет по всем подразделениям

### Ключевые особенности
- **Работа с существующими структурами**: Система не перезаписывает уже созданные файлы, а дополняет структуру новыми сотрудниками
- **Гибкость шаблонов**: Использование настраиваемых Excel-шаблонов
- **Интеллектуальный долив**: Определение существующих и новых отделов
- **Валидация данных**: Проверка корректности входных данных
- **Полная отчетность**: Создание отчетов по подразделениям и общего отчета

## Архитектура

### Структура проекта
```
project/
├── main.py                 # Точка входа
├── config.py              # Конфигурация
├── config.json            # Настройки
├── models.py              # Модели данных
├── core/                  # Основная логика
│   ├── processor.py       # Главный процессор
│   ├── validator.py       # Валидация данных
│   ├── excel_handler.py   # Работа с Excel
│   └── file_manager.py    # Управление файлами
├── gui/                   # Интерфейс
│   ├── main_window.py     # Главное окно
│   ├── create_files_window.py  # Создание файлов
│   └── reports_window.py  # Работа с отчетами
├── templates/             # Шаблоны Excel
│   ├── employee_template.xlsx
│   ├── block_report_template.xlsx
│   └── global_report_template.xlsx
└── logs/                  # Логи
    └── vacation_tool.log
```

### Основные компоненты

#### **Процессор (processor.py)**
Главный компонент, координирующий операции:
- `create_employee_files_to_existing()` - создание файлов в существующей структуре с поддержкой долива
- `update_block_reports()` - создание отчетов по выбранным подразделениям
- `create_general_report()` - создание общего отчета на основе отчетов по блокам
- `scan_target_directory()` - сканирование папки для определения существующих подразделений

#### **Валидатор (validator.py)**
Проверка данных:
- Валидация структуры Excel файлов
- Проверка обязательных полей
- Контроль уникальности табельных номеров
- Проверка наличия шаблонов

#### **Обработчик Excel (excel_handler.py)**
Работа с Excel:
- Создание файлов сотрудников на основе шаблонов
- Чтение данных об отпусках из заполненных файлов
- Создание отчетов по подразделениям с календарной матрицей
- Создание общего отчета по всем подразделениям

#### **Менеджер файлов (file_manager.py)**
Управление файловой системой:
- Создание/дополнение структуры папок по подразделениям
- Сканирование существующих файлов
- Логика "доливки" новых сотрудников без изменения существующих файлов

## Форматы данных

### Входной файл (штатное расписание)
- **Формат**: Excel (.xlsx, .xls)
- **Заголовки**: в 5-й строке (настраивается)
- **Обязательные столбцы**:
  - "ФИО работника"
  - "Табельный номер"
  - "Подразделение 1"
- **Дополнительные столбцы**: "Должность", "Подразделение 2", "Подразделение 3", "Подразделение 4"

### Выходные файлы сотрудников
- **Формат**: Excel (.xlsx)
- **Название**: `ФИО (табельныйНомер).xlsx`
- **Содержимое**: Персональные данные + таблица для планирования отпусков (строки 9-23)

### Отчеты
- **Отчет по подразделению**: `Отчет по блоку_НазваниеОтдела_YYYYMMDD_HHMMSS.xlsx`
  - Лист Report: Сводка по сотрудникам + календарная матрица отпусков
  - Лист Print: Данные в печатном виде
- **Общий отчет**: `ОБЩИЙ_ОТЧЕТ_YYYYMMDD_HHMMSS.xlsx`
  - Сводка по всем подразделениям

## Логика работы с существующими файлами

### Алгоритм "доливки"
1. **Сканирование** целевой папки на предмет существующих подразделений
2. **Подсчет** уже созданных файлов сотрудников в каждом подразделении
3. **Определение** существующих и новых отделов
4. **Определение** новых сотрудников (кого нет в папках)
5. **Создание** только недостающих файлов и папок
6. **Сохранение** существующей структуры без изменений

### Вывод информации о доливе
- **Существующие отделы**: список через запятую
- **Новые отделы**: список через запятую
- **Статистика**: количество новых и пропускаемых сотрудников

### Логика активации кнопок
- Кнопка "Создать файлы" активна только при наличии новых сотрудников
- Если все записи уже есть - кнопка неактивна
- Отображение точного количества файлов к созданию

## Система отчетов

### Отчеты по подразделениям
- **Создание**: На основе заполненных файлов сотрудников
- **Содержимое**: 
  - Статистика по заполнению планов отпусков
  - Календарная матрица отпусков на 2026 год
  - Данные для печати
- **Выбор подразделений**: Пользователь может выбрать конкретные отделы

### Общий отчет
- **Создание**: На основе отчетов по подразделениям
- **Требование**: Наличие актуальных отчетов по всем выбранным подразделениям
- **Содержимое**: Сводная таблица по всем подразделениям

## Прогресс-бары

### Двухуровневая система прогресса
- **Основной прогресс**: Отделы (показывает общий прогресс обработки)
- **Вторичный прогресс**: Файлы в текущем отделе
- **Информация**: Текущая операция, скорость обработки, оставшееся время

## Бизнес-правила

### Создание файлов
- Один файл на одного сотрудника
- Группировка по подразделениям (папки)
- Не перезаписывать существующие файлы
- "Доливать" только новых сотрудников
- Не изменять структуру существующих файлов

### Валидация данных
- Уникальность табельных номеров
- Обязательность ФИО и подразделения
- Ограничения по количеству записей (1-10000)
- Проверка формата файлов

### Отчетность
- Отчеты создаются только при наличии файлов сотрудников
- Общий отчет требует наличия отчетов по блокам
- Автоматическое определение последних версий отчетов

## Конфигурация

### Настраиваемые параметры (config.json)
```json
{
  "employee_template": "templates/employee_template.xlsx",
  "block_report_template": "templates/block_report_template.xlsx",
  "general_report_template": "templates/global_report_template.xlsx",
  "header_row": 5,
  "processing_time_per_file": 0.3,
  "excel_password": "1111",
  "date_format": "%d.%m.%y",
  "max_employees": 10000,
  "min_employees": 1,
  "window_width": 1000,
  "window_height": 700,
  "log_level": "INFO"
}
```

## Пользовательский интерфейс

### Главное окно
- **Статус шаблонов**: Автоматическая проверка наличия необходимых файлов
- **Кнопка создания файлов**: Запуск основной функции создания файлов сотрудников
- **Кнопка отчетов**: Работа с отчетами по подразделениям и общим отчетом
- **Инструкции**: Пошаговое руководство пользователя

### Окно создания файлов
- **Выбор файлов**: Штатное расписание и целевая папка
- **Валидация**: Автоматическая проверка данных с детализацией ошибок
- **Анализ существующих файлов**: Информация о доливе
- **Статистика**: Информация о количестве записей и подразделений
- **Двухуровневый прогресс**: Отделы и файлы в отделе
- **Результат**: Детальная сводка выполненной операции

### Окно отчетов
- **Вкладка "По подразделениям"**: Создание отчетов по выбранным подразделениям
- **Вкладка "Общий"**: Создание общего отчета по всем подразделениям
- **Выбор подразделений**: Диалог с возможностью выбора конкретных отделов
- **Прогресс обработки**: Отображение хода создания отчетов




=============================================
FILE: config.json
=============================================
Lines: 0

{
  "employee_template": "templates/employee_template v1.1.xlsx",
  "block_report_template": "templates/block_report_template v3.xlsx",
  "general_report_template": "templates/global_report_template.xlsx",
  "header_row": 5,
  "processing_time_per_file": 0.3,
  "excel_password": "1111",
  "date_format": "%d.%m.%y",
  "max_employees": 10000,
  "min_employees": 1,
  "window_width": 1000,
  "window_height": 700,
  "log_level": "INFO"
}



=============================================
FILE: .gitignore
=============================================
Lines: 0

# Byte-compiled / optimized / DLL files
__pycache__/
build/
dist/
test/
tests/
*.py[cod]
*$py.class
test/
tests/
sandbox/
backLog_aka_toDo.md
# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual environment
venv/
ENV/
env/
.venv/
.ENV/
.env/
.venv.bak/
env.bak/
venv.bak/

# PyInstaller
# Usually contains your entire application in one folder
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Type checker
.mypy_cache/
.dmypy.json
dmypy.json

# IDEs and editors
.vscode/
.idea/
*.sublime-project
*.sublime-workspace

# Jupyter Notebook
.ipynb_checkpoints

# Pyre type checker
.pyre/

# pytype
.pytype/

# Cython debug symbols
cython_debug/

# Profiling data
*.prof
*.lprof
*.pstat
*.dat

# dotenv
.env
.env.*

# local notebooks / data
*.sqlite
*.db
*.log
*.csv
*.tsv
*.json
*.yaml
*.yml
*.bak

# macOS / Windows / Linux
.DS_Store
Thumbs.db
ehthumbs.db
Icon?
desktop.ini



=============================================
FILE: builder.bat
=============================================
Lines: 0

@echo off
chcp 65001 >nul
echo Сборка Vacation Tool в .exe...
echo.

REM Удаляем старые файлы
if exist "dist" rmdir /s /q "dist"
if exist "build" rmdir /s /q "build"
if exist "*.spec" del "*.spec"

echo Запуск PyInstaller...
pyinstaller --onefile ^
    --console ^
    --name "VacationTool" ^
    --add-data "config.json;." ^
    --exclude-module "matplotlib" ^
    --exclude-module "pandas" ^
    --exclude-module "numpy" ^
    --exclude-module "PIL" ^
    --exclude-module "scipy" ^
    --exclude-module "pytest" ^
    --optimize=2 ^
    main.py

echo.
echo Создание финальной структуры...
if not exist "release" mkdir "release"
copy "dist\VacationTool.exe" "release\"
copy "config.json" "release\"
if exist "templates" xcopy "templates" "release\templates\" /E /I /Y

echo.
echo ГОТОВО! Сборка завершена!
echo.
echo Результат в папке 'release':
if exist "release\VacationTool.exe" (
    echo    OK VacationTool.exe - СОЗДАН
) else (
    echo    ERROR VacationTool.exe - НЕ НАЙДЕН
)

if exist "release\config.json" (
    echo    OK config.json - СКОПИРОВАН
) else (
    echo    ERROR config.json - НЕ НАЙДЕН
)

if exist "release\templates" (
    echo    OK templates\ - СКОПИРОВАНА
) else (
    echo    ERROR templates\ - НЕ НАЙДЕНА
)
REM Очистка временных файлов после сборки
if exist "build" rmdir /s /q "build"
if exist "*.spec" del "*.spec"
echo.
echo Можно запускать: release\VacationTool.exe
echo Окно закроется через 5 секунд...

REM Ждем 5 секунд и закрываемся автоматически
timeout /t 5 /nobreak >nul



=============================================
FILE: dumper.bat
=============================================
Lines: 0

@echo off
chcp 65001 >nul
setlocal enabledelayedexpansion

:: Dump Python Code - Создание дампа всех Python файлов
:: Автор: Vacation Tool Project
:: Версия: 1.5 (исправленная рабочая версия)

echo ========================================
echo   Dump Python Code v1.5
echo   Создание дампа всех Python файлов
echo ========================================
echo.

:: Получаем текущую дату и время для имени файла
for /f "tokens=1-3 delims=/ " %%a in ('date /t') do (
    set "current_date=%%c%%b%%a"
)
for /f "tokens=1-2 delims=: " %%a in ('time /t') do (
    set "current_time=%%a%%b"
)

:: Убираем точки и пробелы из времени
set "current_time=%current_time:.=%"
set "current_time=%current_time: =%"

:: Имя выходного файла
set "output_file=python_code_dump_%current_date%_%current_time%.txt"

echo Создание дампа: %output_file%
echo.

:: Счетчики
set /a file_count=0
set /a total_lines=0

:: Создаем файл с UTF-8 BOM
powershell -Command "[System.IO.File]::WriteAllText('%output_file%', '', (New-Object System.Text.UTF8Encoding $true))" >nul

:: Создаем заголовок через временный файл
echo =========================================> "%temp%\header.tmp"
echo PYTHON CODE DUMP>> "%temp%\header.tmp"
echo Generated: %date% %time%>> "%temp%\header.tmp"
echo Directory: %cd%>> "%temp%\header.tmp"
echo =========================================>> "%temp%\header.tmp"
echo.>> "%temp%\header.tmp"

powershell -Command "Get-Content '%temp%\header.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\header.tmp" >nul

:: PROJECT STRUCTURE
echo.>> "%temp%\structure.tmp"
echo ###############################################>> "%temp%\structure.tmp"
echo ### PROJECT STRUCTURE>> "%temp%\structure.tmp"
echo ###############################################>> "%temp%\structure.tmp"
echo.>> "%temp%\structure.tmp"
echo === PROJECT STRUCTURE ===>> "%temp%\structure.tmp"

powershell -Command "Get-Content '%temp%\structure.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\structure.tmp" >nul

:: Простое дерево
dir /s /b > "%temp%\tree.tmp"
powershell -Command "Get-Content '%temp%\tree.tmp' -Encoding UTF8 | ForEach-Object { $_.Replace('%cd%\', '') } | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\tree.tmp" >nul

:: Разделитель для файлов
echo.>> "%temp%\separator.tmp"
echo.>> "%temp%\separator.tmp"
echo ###############################################>> "%temp%\separator.tmp"
echo ### PYTHON FILES CONTENT>> "%temp%\separator.tmp"
echo ###############################################>> "%temp%\separator.tmp"
echo.>> "%temp%\separator.tmp"

powershell -Command "Get-Content '%temp%\separator.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\separator.tmp" >nul

:: Обходим все Python файлы
echo Поиск Python файлов...
for /R %%f in (*.py) do (
    call :process_file "%%f"
)

:: Добавляем другие важные файлы
echo.
echo Поиск дополнительных файлов...

if exist "requirements.txt" call :process_text_file "requirements.txt"
if exist "README.md" call :process_text_file "README.md"
if exist "config.json" call :process_text_file "config.json"
if exist ".gitignore" call :process_text_file ".gitignore"

:: Любые .bat файлы (кроме текущего)
for %%f in (*.bat) do (
    if not "%%~nf"=="dump_python_code" (
        call :process_text_file "%%f"
    )
)

:: Статистика
echo.>> "%temp%\stats.tmp"
echo ###############################################>> "%temp%\stats.tmp"
echo ### STATISTICS>> "%temp%\stats.tmp"
echo ###############################################>> "%temp%\stats.tmp"
echo.>> "%temp%\stats.tmp"
echo === STATISTICS ===>> "%temp%\stats.tmp"
echo Total Python files processed: %file_count%>> "%temp%\stats.tmp"
echo Total lines of code: %total_lines%>> "%temp%\stats.tmp"
echo Dump created: %date% %time%>> "%temp%\stats.tmp"
echo =============================================>> "%temp%\stats.tmp"

powershell -Command "Get-Content '%temp%\stats.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"
del "%temp%\stats.tmp" >nul

:: Итоговое сообщение
echo.
echo ========================================
echo Дамп создан успешно!
echo ========================================
echo Файл: %output_file%
echo Обработано файлов: %file_count%
echo Всего строк кода: %total_lines%
echo ========================================
echo.

:: Открываем папку с файлом
echo Открыть папку с дампом? (Y/N)
set /p "choice=Ваш выбор: "
if /i "%choice%"=="Y" explorer .

goto :end

:: Функция обработки файла
:process_file
set "filepath=%~1"
set "filename=%~nx1"
set "relative_path=%filepath:*%cd%\=%"

echo Обработка: %relative_path%

:: Подсчитываем строки
set /a current_lines=0
for /f %%i in ('find /c /v "" "%filepath%" 2^>nul') do set /a current_lines=%%i
if !current_lines! EQU 0 set /a current_lines=0
set /a total_lines+=current_lines

:: Создаем заголовок во временном файле
echo.> "%temp%\file_header.tmp"
echo =============================================>> "%temp%\file_header.tmp"
echo FILE: %relative_path%>> "%temp%\file_header.tmp"
echo =============================================>> "%temp%\file_header.tmp"
echo Lines: !current_lines!>> "%temp%\file_header.tmp"
echo.>> "%temp%\file_header.tmp"

:: Записываем заголовок
powershell -Command "Get-Content '%temp%\file_header.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Записываем содержимое файла
powershell -Command "Get-Content '%filepath%' -Encoding UTF8 -ErrorAction SilentlyContinue | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Добавляем пустые строки
echo.>> "%temp%\empty.tmp"
echo.>> "%temp%\empty.tmp"
powershell -Command "Get-Content '%temp%\empty.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Удаляем временные файлы
del "%temp%\file_header.tmp" >nul 2>&1
del "%temp%\empty.tmp" >nul 2>&1

set /a file_count+=1
goto :eof

:: Функция обработки текстовых файлов
:process_text_file
set "filepath=%~1"
set "filename=%~nx1"

echo Обработка: %filename%

:: Подсчитываем строки
set /a current_lines=0
for /f %%i in ('find /c /v "" "%filepath%" 2^>nul') do set /a current_lines=%%i
if !current_lines! EQU 0 set /a current_lines=0
set /a total_lines+=current_lines

:: Создаем заголовок во временном файле
echo.> "%temp%\text_header.tmp"
echo =============================================>> "%temp%\text_header.tmp"
echo FILE: %filename%>> "%temp%\text_header.tmp"
echo =============================================>> "%temp%\text_header.tmp"
echo Lines: !current_lines!>> "%temp%\text_header.tmp"
echo.>> "%temp%\text_header.tmp"

:: Записываем заголовок
powershell -Command "Get-Content '%temp%\text_header.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Записываем содержимое файла
powershell -Command "Get-Content '%filepath%' -Encoding UTF8 -ErrorAction SilentlyContinue | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Добавляем пустые строки
echo.>> "%temp%\empty2.tmp"
echo.>> "%temp%\empty2.tmp"
powershell -Command "Get-Content '%temp%\empty2.tmp' -Encoding UTF8 | Out-File -FilePath '%output_file%' -Encoding UTF8 -Append"

:: Удаляем временные файлы
del "%temp%\text_header.tmp" >nul 2>&1
del "%temp%\empty2.tmp" >nul 2>&1

set /a file_count+=1
goto :eof

:end
echo Нажмите любую клавишу для выхода...
pause >nul



###############################################
### STATISTICS
###############################################

=== STATISTICS ===
Total Python files processed: 18
Dump created: 15.07.2025 11:12:38,80
=============================================
